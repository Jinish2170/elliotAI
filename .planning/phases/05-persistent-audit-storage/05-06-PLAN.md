---
phase: 05-persistent-audit-storage
plan: 06
type: execute
wave: 4
depends_on: [05-01, 05-02]
files_modified:
  - backend/tests/test_audit_persistence.py
autonomous: true
requirements:
  - CORE-06-5

must_haves:
  truths:
    - test_concurrent_audit_writes creates N audits simultaneously via asyncio.gather
    - All concurrent writes succeed without database locking errors
    - test_concurrent_read_write verifies reads don't block writes in WAL mode
    - All tests pass at least 10 concurrent operations
    - Clean teardown deletes test database file after each test
  artifacts:
    - path: "backend/tests/test_audit_persistence.py"
      provides: "Concurrent write and read-write tests for SQLite WAL mode"
      exports: ["test_concurrent_audit_writes", "test_concurrent_read_write", "audit_session_fixture"]
  key_links:
    - from: "backend/tests/test_audit_persistence.py"
      to: "veritas/db/__init__.py"
      via: "import init_database, AsyncSession"
      pattern: "from veritas.db import"
    - from: "backend/tests/test_audit_persistence.py"
      to: "veritas/db/repositories.py"
      via: "import AuditRepository"
      pattern: "from veritas.db.repositories import"
    - from: "backend/tests/test_audit_persistence.py"
      to: "pytest-asyncio"
      via: "@pytest.mark.asyncio decorator"
      pattern: "pytest.mark.asyncio"
---

<objective>
Create concurrent write simulation tests to verify SQLite WAL mode handles concurrent audit operations correctly.

Purpose: Validate that WAL mode configuration enables true concurrent access - multiple writes succeed without locking, reads don't block writes. These tests ensure the persistence layer is production-ready for multiple simultaneous audits.

Output: backend/tests/test_audit_persistence.py with concurrent write and read-write tests.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistent-audit-storage/05-RESEARCH.md
@.planning/phases/05-persistent-audit-storage/05-01-SUMMARY.md
@.planning/phases/05-persistent-audit-storage/05-02-SUMMARY.md
@backend/tests/test_audit_runner_queue.py
</context>

<tasks>

<task type="auto">
  <name>Create concurrent audit persistence tests</name>
  <files>
    - backend/tests/test_audit_persistence.py
  </files>
  <action>
    Create backend/tests/test_audit_persistence.py with concurrent operation tests:

    1. Add imports:
       ```python
       import asyncio
       import pytest
       from datetime import datetime
       from pathlib import Path
       from sqlalchemy.ext.asyncio import AsyncSession

       from veritas.db import init_database, engine, AsyncSessionLocal, Base
       from veritas.db.models import Audit, AuditStatus
       from veritas.db.repositories import AuditRepository
       ```

    2. Create pytest fixture for test database session:
       ```python
       @pytest.fixture
       async def audit_session():
           """
           Create a fresh database for each test.
           Uses in-memory SQLite for fast test execution.
           """
           # Use in-memory database for tests (clean slate each run)
           test_engine = create_async_engine(
               "sqlite+aiosqlite:///:memory:",
               connect_args={"check_same_thread": False},
           )

           # Create all tables
           async with test_engine.begin() as conn:
               await conn.run_sync(Base.metadata.create_all)

           # Session factory for this test
           TestSessionLocal = async_sessionmaker(
               test_engine,
               class_=AsyncSession,
               expire_on_commit=False,
           )

           async with TestSessionLocal() as session:
               yield session
       ```

    3. Create test_concurrent_audit_writes:
       ```python
       @pytest.mark.asyncio
       async def test_concurrent_audit_writes(audit_session: AsyncSession):
           """
           Test SQLite WAL mode handles concurrent writes correctly.

           Creates N audits simultaneously via asyncio.gather().
           Verifies all writes succeed and data persists correctly.
           """
           repo = AuditRepository(audit_session)
           num_concurrent = 10

           async def create_audit(index: int) -> Audit:
               audit = Audit(
                   id=f"vrts_test_{index:08d}",
                   url=f"https://test-{index}.com",
                   audit_tier="quick_scan",
                   verdict_mode="expert",
                   status=AuditStatus.COMPLETED,
                   trust_score=50.0 + index,
                   risk_level="low" if index > 5 else "suspicious",
                   pages_scanned=1,
                   elapsed_seconds=5.0,
                   created_at=datetime.utcnow(),
                   started_at=datetime.utcnow(),
                   completed_at=datetime.utcnow(),
               )
               return await repo.create(audit)

           # Run concurrent writes
           tasks = [create_audit(i) for i in range(num_concurrent)]
           results = await asyncio.gather(*tasks, return_exceptions=True)

           # Verify all writes succeeded (no exceptions)
           assert all(isinstance(r, Audit) for r in results), \
               f"Some writes failed: {[type(r) for r in results if not isinstance(r, Audit)]}"

           # Verify all audits persisted
           for i in range(num_concurrent):
               audit = await repo.get_by_id(f"vrts_test_{i:08d}")
               assert audit is not None, f"Audit {i} not persisted"
               assert audit.trust_score == 50.0 + i, f"Audit {i} has wrong score: {audit.trust_score}"
               assert audit.status == AuditStatus.COMPLETED
       ```

    4. Create test_concurrent_read_write:
       ```python
       @pytest.mark.asyncio
       async def test_concurrent_read_write(audit_session: AsyncSession):
           """
           Test that reads don't block writes in WAL mode.

           Runs continuous reads while performing writes.
           Verifies reads don't timeout and writes complete.
           """
           repo = AuditRepository(audit_session)

           # Create initial audit
           audit = Audit(
               id="vrts_readwrite_test",
               url="https://test-concurrent.com",
               audit_tier="standard_audit",
               verdict_mode="expert",
               status=AuditStatus.RUNNING,
               trust_score=50.0,
               created_at=datetime.utcnow(),
               started_at=datetime.utcnow(),
           )
           await repo.create(audit)

           async def read_task() -> None:
               """Continuous reads while writes happen."""
               for i in range(20):
                   a = await repo.get_by_id("vrts_readwrite_test")
                   assert a is not None, f"Read task failed at iteration {i}"
                   await asyncio.sleep(0.005)  # Small delay between reads

           async def write_task() -> None:
               """Update audit in loop."""
               for i in range(10):
                   # Get, update, save
                   a = await repo.get_by_id("vrts_readwrite_test")
                   a.trust_score = 50.0 + i
                   a.pages_scanned = i + 1
                   await repo.update(a)
                   await asyncio.sleep(0.01)

           # Run concurrent read + write with 1 read task and 3 write tasks
           await asyncio.gather(
               read_task(),
               write_task(),
               write_task(),
               write_task(),
           )

           # Verify final state (one of the writes should have completed)
           final = await repo.get_by_id("vrts_readwrite_test")
           assert final is not None
           assert final.trust_score >= 50.0, f"Trust score {final.trust_score} < 50.0"
           assert final.pages_scanned > 0, f"Pages scanned must be positive, got {final.pages_scanned}"
       ```

    5. Create test_wal_mode_enabled:
       ```python
       @pytest.mark.asyncio
       async def test_wal_mode_enabled(audit_session: AsyncSession):
           """
           Verify WAL mode is enabled for the database.

           Confirms PRAGMA journal_mode returns 'wal'.
           """
           from sqlalchemy import text

           result = await audit_session.execute(text("PRAGMA journal_mode"))
           journal_mode = result.scalar_one()

           assert journal_mode == "wal", \
               f"WAL mode not enabled, got: {journal_mode}. Check init_database() configuration."
       ```

    6. Create cleanup script for test database:
       ```python
       @pytest.fixture(autouse=True)
       async def cleanup_database():
           """
           Clean up test database files after each test.
           Only runs if file-based database exists.
           """
           yield

           # Remove test database if it exists
           test_db = Path("data/veritas_audits_test.db")
           if test_db.exists():
               test_db.unlink()
       ```

    Reference patterns from backend/tests/test_audit_runner_queue.py for test structure.

    IMPORTANT: Use in-memory SQLite (`sqlite+aiosqlite:///:memory:`) for audit_session fixture to avoid file I/O overhead and ensure clean state.
  </action>
  <verify>
    Run pytest backend/tests/test_audit_persistence.py -v - verify all tests pass
  </verify>
  <done>
    All 3 tests pass (test_concurrent_audit_writes, test_concurrent_read_write, test_wal_mode_enabled); no database locking errors.
  </done>
</task>

</tasks>

<verification>
1. Run tests: `pytest backend/tests/test_audit_persistence.py -v`
2. Verify concurrent writes: All 10 audits created successfully in test_concurrent_audit_writes
3. Verify concurrent read-write: test_concurrent_read_write completes without timeouts
4. Verify WAL mode: test_wal_mode_enabled confirms "wal" journal_mode
5. Check for locking errors: Verify no "database is locked" errors in test output
</verification>

<success_criteria>
- test_concurrent_audit_writes passes with N=10 concurrent operations
- test_concurrent_read_write passes with 3 concurrent writers and continuous reads
- test_wal_mode_enabled confirms PRAGMA journal_mode returns "wal"
- All tests complete without database locking exceptions
- Total test run time < 10 seconds (in-memory SQLite)
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistent-audit-storage/05-06-SUMMARY.md` with test results and WAL mode verification notes.
</output>
