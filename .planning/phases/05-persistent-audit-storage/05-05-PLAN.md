---
phase: 05-persistent-audit-storage
plan: 05
type: execute
wave: 3
depends_on: [05-02]
files_modified:
  - backend/routes/audit.py
autonomous: true
requirements:
  - CORE-05-5

must_haves:
  truths:
    - GET /audits/history endpoint returns paginated list of audits
    - Optional filters: status, risk_level, limit (default 20, max 100), offset
    - Response includes audit_id, url, status, trust_score, risk_level, timestamps
    - GET /audits/compare endpoint accepts list of audit_ids and returns comparison
    - Compare endpoint shows trust_score_delta and risk_level_changes between audits
  artifacts:
    - path: "backend/routes/audit.py"
      provides: "Audit history and comparison API endpoints"
      exports: ["get_audit_history", "compare_audits"]
  key_links:
    - from: "backend/routes/audit.py"
      to: "veritas/db/repositories.py"
      via: "import AuditRepository"
      pattern: "from veritas.db.repositories import AuditRepository"
    - from: "backend/routes/audit.py"
      to: "/audits/history endpoint"
      via: "GET request with optional filters"
      pattern: "@router.get.*history"
    - from: "backend/routes/audit.py"
      to: "/audits/compare endpoint"
      via: "POST request with audit_ids list"
      pattern: "@router.post.*compare"
---

<objective>
Create audit history API endpoints for historical audit retrieval and comparison.

Purpose: Enable users to browse past audit results and compare multiple audits (e.g., same URL over time). The API provides paginated results with optional filters and a comparison endpoint for analyzing trust score changes.

Output: Two new API endpoints in backend/routes/audit.py for history and comparison.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistent-audit-storage/05-RESEARCH.md
@.planning/phases/05-persistent-audit-storage/05-02-SUMMARY.md
@backend/routes/audit.py
@veritas/db/models.py
@veritas/db/repositories.py
</context>

<tasks>

<task type="auto">
  <name>Create audit history API endpoints</name>
  <files>
    - backend/routes/audit.py
  </files>
  <action>
    Add two new API endpoints to backend/routes/audit.py:

    1. Add imports if not already present:
       - from fastapi import Query
       - from typing import Optional
       - from veritas.db.models import AuditStatus

    2. Create GET /audits/history endpoint:

       ```python
       @router.get("/audits/history")
       async def get_audit_history(
           db: DbSession,
           limit: int = Query(20, ge=1, le=100, description="Number of audits to return (1-100)"),
           offset: int = Query(0, ge=0, description="Pagination offset"),
           status_filter: Optional[str] = Query(None, description="Filter by audit status"),
           risk_level_filter: Optional[str] = Query(None, description="Filter by risk level")
       ):
           """
           Get paginated audit history with optional filters.

           Returns list of audits sorted by created_at descending (newest first).
           Supports filtering by status and risk_level.
           """
           # Only read from database (in-memory doesn't have full history)
           repo = AuditRepository(db)

           # Build query with filters
           query = select(Audit).order_by(Audit.created_at.desc())

           if status_filter:
               try:
                   status = AuditStatus(status_filter)
                   query = query.where(Audit.status == status)
               except ValueError:
                   pass  # Invalid status, ignore filter

           if risk_level_filter:
               query = query.where(Audit.risk_level == risk_level_filter)

           query = query.limit(limit).offset(offset)
           result = await db.execute(query)
           audits = result.scalars().all()

           # Convert to response format
           return {
               "audits": [
                   {
                       "audit_id": a.id,
                       "url": a.url,
                       "status": a.status.value,
                       "audit_tier": a.audit_tier,
                       "verdict_mode": a.verdict_mode,
                       "trust_score": a.trust_score,
                       "risk_level": a.risk_level,
                       "signal_scores": a.signal_scores,
                       "site_type": a.site_type,
                       "site_type_confidence": a.site_type_confidence,
                       "pages_scanned": a.pages_scanned,
                       "screenshots_count": a.screenshots_count,
                       "elapsed_seconds": a.elapsed_seconds,
                       "created_at": a.created_at.isoformat() if a.created_at else None,
                       "started_at": a.started_at.isoformat() if a.started_at else None,
                       "completed_at": a.completed_at.isoformat() if a.completed_at else None,
                   }
                   for a in audits
               ],
               "count": len(audits),
               "limit": limit,
               "offset": offset,
           }
       ```

    3. Create POST /audits/compare endpoint:

       ```python
       @router.post("/audits/compare")
       async def compare_audits(
           audit_ids: list[str],
           db: DbSession,
       ):
           """
           Compare multiple audits to detect changes over time.

           Accepts a list of audit_ids and returns:
           - Full audit data for each ID
           - Trust score delta between consecutive audits
           - Risk level changes
           - Pattern changes (in findings counts)
           """
           if not audit_ids:
               raise HTTPException(status_code=400, detail="audit_ids list is required")

           if len(audit_ids) < 2:
               raise HTTPException(status_code=400, detail="At least 2 audit IDs required for comparison")

           repo = AuditRepository(db)

           # Fetch all audits with their findings
           audits_data = []
           for audit_id in audit_ids:
               audit = await repo.get_by_id(audit_id)
               if not audit:
                   continue  # Skip missing audits

               # Count findings by severity
               findings_summary = {
                   "total": len(audit.findings),
                   "critical": sum(1 for f in audit.findings if f.severity == "critical"),
                   "high": sum(1 for f in audit.findings if f.severity == "high"),
                   "medium": sum(1 for f in audit.findings if f.severity == "medium"),
                   "low": sum(1 for f in audit.findings if f.severity == "low"),
               }

               # Format audit summary
               audits_data.append({
                   "audit_id": audit.id,
                   "url": audit.url,
                   "status": audit.status.value,
                   "trust_score": audit.trust_score,
                   "risk_level": audit.risk_level,
                   "site_type": audit.site_type,
                   "created_at": audit.created_at.isoformat() if audit.created_at else None,
                   "completed_at": audit.completed_at.isoformat() if audit.completed_at else None,
                   "findings_summary": findings_summary,
                   "screenshots_count": a.screenshots_count,
               })

           if not audits_data:
               raise HTTPException(status_code=404, detail="No valid audits found")

           # Sort by created_at (earliest first for delta calculation)
           audits_data.sort(key=lambda a: a["created_at"] or "")

           # Calculate deltas
           trust_score_deltas = []
           for i in range(1, len(audits_data)):
               prev_score = audits_data[i-1]["trust_score"] or 0
               curr_score = audits_data[i]["trust_score"] or 0
               delta = curr_score - prev_score
               trust_score_deltas.append({
                   "from_audit_id": audits_data[i-1]["audit_id"],
                   "to_audit_id": audits_data[i]["audit_id"],
                   "delta": delta,
                   "percentage_change": (delta / prev_score * 100) if prev_score != 0 else None,
               })

           # Detect risk level changes
           risk_level_changes = []
           for i in range(1, len(audits_data)):
               prev_risk = audits_data[i-1]["risk_level"]
               curr_risk = audits_data[i]["risk_level"]
               if prev_risk != curr_risk:
                   risk_level_changes.append({
                       "from_audit_id": audits_data[i-1]["audit_id"],
                       "to_audit_id": audits_data[i]["audit_id"],
                       "from": prev_risk or "unknown",
                       "to": curr_risk or "unknown",
                   })

           return {
               "audits": audits_data,
               "trust_score_deltas": trust_score_deltas,
               "risk_level_changes": risk_level_changes,
           }
       ```

    Reference 05-RESEARCH.md lines 527-592 for API endpoint patterns.
  </action>
  <verify>
    Run python -m backend.routes.audit - verify no import errors
  </verify>
  <done>
    GET /audits/history endpoint exists with pagination and filters; POST /audits/compare endpoint exists with delta calculation.
  </done>
</task>

</tasks>

<verification>
1. Verify endpoints exist: Start backend, run `curl http://localhost:8000/docs` - verify history and compare endpoints listed
2. Test history endpoint: Run `curl "http://localhost:8000/audits/history?limit=5"` - should return list of audits
3. Test pagination: Run `curl "http://localhost:8000/audits/history?limit=10&offset=10"` - should return second page
4. Test filters: Run `curl "http://localhost:8000/audits/history?status_filter=completed"` - should filter by status
5. Test compare endpoint: Run `curl -X POST -H "Content-Type: application/json" -d '{"audit_ids": ["vrts_00000001", "vrts_00000002"]}' http://localhost:8000/audits/compare`
</verification>

<success_criteria>
- GET /audits/history endpoint returns paginated audit list
- History endpoint supports filtering by status and risk_level
- POST /audits/compare endpoint accepts multiple audit_ids
- Compare endpoint calculates trust_score_delta and risk_level_changes
- API documentation available via OpenAPI/Swagger UI
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistent-audit-storage/05-05-SUMMARY.md` with API endpoint documentation and example requests.
</output>
