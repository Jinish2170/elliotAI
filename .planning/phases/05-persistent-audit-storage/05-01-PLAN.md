---
phase: 05-persistent-audit-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - veritas/db/__init__.py
  - veritas/db/models.py
  - veritas/db/config.py
autonomous: true
requirements:
  - CORE-05
  - CORE-05-2
  - CORE-06-5

must_haves:
  truths:
    - SQLite database file exists in data/veritas_audits.db on first backend startup
    - Database has WAL mode enabled (PRAGMA journal_mode=WAL)
    - All audit-related tables (audits, audit_findings, audit_screenshots, audit_events) exist
    - Tables contain all required columns from research document schema
    - Indexes exist on frequently queried columns (status, created_at, trust_score, url)
  artifacts:
    - path: "veritas/db/__init__.py"
      provides: "Database initialization and async engine setup"
      exports: ["init_database", "get_db", "AsyncSession", "engine"]
    - path: "veritas/db/models.py"
      provides: "SQLAlchemy ORM models for audit data"
      contains: ["class Audit", "class AuditFinding", "class AuditScreenshot"]
    - path: "veritas/db/config.py"
      provides: "Database configuration and WAL mode settings"
      exports: ["DATABASE_URL", "Base"]
    - path: "data/veritas_audits.db"
      provides: "SQLite database file (created on first run)"
  key_links:
    - from: "veritas/db/__init__.py"
      to: "veritas/db/config.py"
      via: "import DATABASE_URL, Base"
      pattern: "from veritas.db.config import"
    - from: "veritas/db/__init__.py"
      to: "veritas/db/models.py"
      via: "import models to create tables"
      pattern: "import.*models"
    - from: "veritas/db/__init__.py"
      to: "PRAGMA journal_mode=WAL"
      via: "database initialization async function"
      pattern: "PRAGMA journal_mode=WAL"
---

<objective>
Create SQLAlchemy ORM models and initialize SQLite database with WAL mode for concurrent write support.

Purpose: Establish the foundational database layer for audit persistence without modifying existing routes. The database initialization runs once on startup, creating tables and configuring WAL mode PRAGMAs for optimal concurrent access.

Output: veritas/db/ package with models, config, and initialization; SQLite database file created on first run.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistent-audit-storage/05-RESEARCH.md
@backend/routes/audit.py
@veritas/agents/judge.py
</context>

<tasks>

<task type="auto">
  <name>Create SQLAlchemy models and database configuration</name>
  <files>
    - veritas/db/__init__.py
    - veritas/db/models.py
    - veritas/db/config.py
  </files>
  <action>
    Create the veritas/db package with three files:

    1. **veritas/db/config.py**:
       - Set DATABASE_URL = "sqlite+aiosqlite:///./data/veritas_audits.db"
       - Create declarative_base() instance as Base
       - Include constants for PRAGMA settings (SYNCHRONOUS, CACHE_SIZE, WAL_AUTO_CHECKPOINT)

    2. **veritas/db/models.py**:
       - Import from config: DATABASE_URL, Base
       - Create AuditStatus enum (queued, running, completed, error, disconnected)
       - Create Audit model with all fields from 05-RESEARCH.md lines 434-482:
         * id, url, status, audit_tier, verdict_mode
         * trust_score, risk_level, signal_scores, narrative
         * site_type, site_type_confidence, security_results
         * pages_scanned, screenshots_count, elapsed_seconds
         * errors, error_message
         * started_at, completed_at, created_at, updated_at
         * relationships: findings, screenshots, events (cascade="all, delete-orphan")
         * __table_args__: indexes on status, created_at, trust_score, url

       - Create AuditFinding model (lines 484-505):
         * id, audit_id (FK with ondelete=CASCADE)
         * pattern_type, category, severity, confidence
         * description, plain_english, screenshot_index, created_at
         * relationship to Audit, indexes on audit_id, pattern_type

       - Create AuditScreenshot model (lines 507-524):
         * id, audit_id (FK with ondelete=CASCADE)
         * file_path, label, index_num, file_size_bytes, created_at
         * relationship to Audit, index on audit_id

       - Create AuditEvent model (for progress events):
         * id, audit_id (FK with ondelete=CASCADE)
         * event_type, data (JSON), timestamp
         * relationship to Audit, index on audit_id

    3. **veritas/db/__init__.py**:
       - Import from sqlalchemy: create_async_engine, async_sessionmaker, text
       - Import models from veritas.db.models
       - Create engine with DATABASE_URL, connect_args={"check_same_thread": False}
       - Create AsyncSessionLocal sessionmaker with expire_on_commit=False
       - Define async get_db() generator for FastAPI dependency injection
       - Define async init_database() function:
         * Use engine.begin() context manager
         * Execute PRAGMA journal_mode=WAL
         * Execute PRAGMA synchronous=NORMAL
         * Execute PRAGMA cache_size=-64000
         * Execute PRAGMA temp_store=MEMORY
         * Execute PRAGMA wal_autocheckpoint=1000
         * Call Base.metadata.create_all(conn)
       - Export: engine, AsyncSessionLocal, get_db, init_database, Base

    IMPORTANT: Do NOT modify backend/routes/audit.py in this plan. Only create the database infrastructure.
  </action>
  <verify>
    Run python -c "from veritas.db import init_database, Base, models; print('Models loaded:', [m.__name__ for m in Base.__subclasses__()])" to verify models import correctly.
  </verify>
  <done>
    All four models (Audit, AuditFinding, AuditScreenshot, AuditEvent import without errors, and init_database function exists.
  </done>
</task>

</tasks>

<verification>
1. Verify models import: Run `python -c "from veritas.db.models import Audit, AuditFinding, AuditScreenshot, AuditEvent; print('All models imported')"`
2. Verify configuration: Run `python -c "from veritas.db.config import DATABASE_URL, Base; print('DB URL:', DATABASE_URL)"`
3. Verify initialization: Run `python -c "import asyncio; from veritas.db import init_database; asyncio.run(init_database()); print('Database initialized')"` - this should create data/veritas_audits.db
4. Verify table structure: Run `sqlite3 data/veritas_audits.db ".schema audits"` to confirm audits table exists with WAL mode (check sqlite3 data/veritas_audits.db "PRAGMA journal_mode")
</verification>

<success_criteria>
- veritas/db package created with 3 files
- All four SQLAlchemy models defined with correct relationships and indexes
- init_database() function enables WAL mode and creates all tables
- SQLite database file created in data/veritas_audits.db on first initialization
- PRAGMA journal_mode returns "wal" when queried
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistent-audit-storage/05-01-SUMMARY.md` with the tables created, WAL mode status, and any model customization notes.
</output>
