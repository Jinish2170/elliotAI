---
phase: 05-persistent-audit-storage
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - veritas/db/repositories.py
  - backend/routes/audit.py
autonomous: true
requirements:
  - CORE-05
  - CORE-05-5

must_haves:
  truths:
    - AuditRepository class exists with get_by_id, create, update methods
    - Repository uses AsyncSession for all database operations
    - FastAPI routes can inject DbSession via Depends(get_db)
    - create method saves audit with cascade to related objects (findings, screenshots, events)
  artifacts:
    - path: "veritas/db/repositories.py"
      provides: "Repository pattern for audit database operations"
      exports: ["AuditRepository", "AuditRepository.get_by_id", "AuditRepository.create", "AuditRepository.update", "AuditRepository.list_recent"]
    - path: "backend/routes/audit.py"
      provides: "Updated routes with DbSession dependency injection"
      exports: ["DbSession"]
  key_links:
    - from: "veritas/db/repositories.py"
      to: "veritas/db/models.py"
      via: "import Audit, AuditFinding, etc."
      pattern: "from veritas.db.models import"
    - from: "backend/routes/audit.py"
      to: "veritas/db/__init__.py"
      via: "import get_db for dependency injection"
      pattern: "from veritas.db import get_db"
    - from: "backend/routes/audit.py"
      to: "veritas/db/repositories.py"
      via: "import AuditRepository"
      pattern: "from veritas.db.repositories import"
---

<objective>
Create repository layer for database operations and integrate FastAPI dependency injection for AsyncSession.

Purpose: Encapsulate all database CRUD operations in AuditRepository class, providing a clean interface for audit persistence. This separation enables easy testing and migration to other databases.

Output: veritas/db/repositories.py with AuditRepository; backend/routes/audit.py updated with DbSession dependency.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistent-audit-storage/05-RESEARCH.md
@.planning/phases/05-persistent-audit-storage/05-01-PLAN.md
@backend/routes/audit.py
@veritas/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Create AuditRepository with CRUD operations</name>
  <files>
    - veritas/db/repositories.py
  </files>
  <action>
    Create veritas/db/repositories.py with AuditRepository class:

    1. Import from veritas.db: AsyncSession
    2. Import from veritas.db.models: Audit, AuditFinding, AuditScreenshot, AuditStatus
    3. Import from sqlalchemy: select, and_
    4. Import from sqlalchemy.orm: selectinload

    Implement AuditRepository class with constructor accepting db: AsyncSession:

    Methods:
    - **async get_by_id(self, audit_id: str) -> Audit | None**:
      * Execute select(Audit).where(Audit.id == audit_id).options(selectinload(Audit.findings), selectinload(Audit.screenshots))
      * Return scalar_one_or_none()

    - **async create(self, audit: Audit) -> Audit**:
      * self.db.add(audit) - cascade handles related objects
      * await self.db.commit()
      * await self.db.refresh(audit)
      * Return audit

    - **async update(self, audit: Audit) -> Audit**:
      * self.db.add(audit) - SQLAlchemy tracks changes
      * await self.db.commit()
      * await self.db.refresh(audit)
      * Return audit

    - **async update_status(self, audit_id: str, status: AuditStatus, error_message: str | None = None) -> bool**:
      * Execute select(Audit).where(Audit.id == audit_id)
      * If found, update status and error_message, commit, return True
      * Else return False

    - **async list_recent(self, limit: int = 20, offset: int = 0, status_filter: AuditStatus | None = None) -> list[Audit]**:
      * Build query: select(Audit).order_by(Audit.created_at.desc())
      * Add where clause if status_filter is not None
      * Apply limit and offset
      * Return list(result.scalars().all())

    - **async get_by_url(self, url: str, limit: int = 5) -> list[Audit]**:
      * Execute select(Audit).where(Audit.url == url).order_by(Audit.created_at.desc()).limit(limit)
      * Return list of past audits for this URL (for comparison)

    Reference 05-RESEARCH.md lines 119-159 for repository pattern.

    IMPORTANT: Do NOT modify audit routes in this task - that's in the next task.
  </action>
  <verify>
    Run python -c "from veritas.db.repositories import AuditRepository; print('Repository imported:', hasattr(AuditRepository, 'get_by_id'))"
  </verify>
  <done>
    AuditRepository class exists with all required methods (get_by_id, create, update, update_status, list_recent, get_by_url).
  </done>
</task>

<task type="auto">
  <name>Update audit routes with DbSession dependency injection</name>
  <files>
    - backend/routes/audit.py
  </files>
  <action>
    Update backend/routes/audit.py to add database session support:

    1. Add import at top:
       - from typing import Annotated
       - from veritas.db import get_db, AsyncSession

    2. Create type alias for dependency injection:
       - DbSession = Annotated[AsyncSession, Depends(get_db)]

    3. Add db parameter to ALL route functions using DbSession dependency injection:
       - @router.post("/audit/start") -> async def start_audit(req: AuditStartRequest, db: DbSession):
       - @router.websocket("/audit/stream/{audit_id}") -> async def stream_audit(ws: WebSocket, audit_id: str, db: DbSession):
       - @router.get("/audit/{audit_id}/status") -> async def audit_status(audit_id: str, db: DbSession):

    4. At the bottom of the file, add empty database event handlers (to be filled in Plan 05-04):
       - async def on_audit_started(audit_id: str, data: dict, db: AsyncSession) -> None:
           pass  # TODO: Save to database in Plan 04

       - async def on_audit_completed(audit_id: str, result: dict, db: AsyncSession) -> None:
           pass  # TODO: Save to database in Plan 04

       - async def on_audit_error(audit_id: str, error: str, db: AsyncSession) -> None:
           pass  # TODO: Save to database in Plan 04

    5. In stream_audit, call these event handlers at appropriate times:
       - After _audits[audit_id]["status"] = "running" -> await on_audit_started(audit_id, {...}, db)
       - In finally block: if completed -> await on_audit_completed(...) or if error -> await on_audit_error(...)
       - Pass db session to the handlers

    IMPORTANT: Do NOT implement the actual database writes in this task - that's in Plan 05-04. Only add the dependency injection and skeleton handlers.
  </action>
  <verify>
    Run python -m backend.routes.audit - if no import errors, verify routes have db parameter.
  </verify>
  <done>
    All three route functions accept db: DbSession parameter; event handler skeletons exist and are called in stream_audit.
  </done>
</task>

</tasks>

<verification>
1. Verify repository methods: Run `python -c "from veritas.db.repositories import AuditRepository; import inspect; print([m for m in dir(AuditRepository) if not m.startswith('_')])"`
2. Verify imports work: `python -c "from backend.routes.audit import router, DbSession; print('Imports OK')"`
3. Verify route signatures: Check that all routes have `db: DbSession` parameter
4. Verify handler skeletons: Check that on_audit_started, on_audit_completed, on_audit_error exist and are called
</verification>

<success_criteria>
- AuditRepository class with 6 methods (get_by_id, create, update, update_status, list_recent, get_by_url)
- All three audit route functions have db: DbSession parameter
- Event handler skeletons exist and are called in stream_audit
- No actual database writes yet (deferred to Plan 05-04)
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistent-audit-storage/05-02-SUMMARY.md` with the repository methods implemented and route changes.
</output>
