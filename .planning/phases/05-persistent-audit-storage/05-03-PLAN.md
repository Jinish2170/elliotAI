---
phase: 05-persistent-audit-storage
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - veritas/screenshots/storage.py
autonomous: true
requirements:
  - CORE-05-4
  - CORE-06-5

must_haves:
  truths:
    - Screenshots are saved to filesystem in data/screenshots/{audit_id} directories
    - Filenames include timestamp and UUID for uniqueness
    - save() method returns (filepath, file_size_bytes) tuple
    - delete() method removes all screenshots for an audit_id
    - Path traversal protection validates filepaths stay within base directory
  artifacts:
    - path: "veritas/screenshots/storage.py"
      provides: "Screenshot filesystem storage service"
      exports: ["ScreenshotStorage", "ScreenshotStorage.save", "ScreenshotStorage.delete", "ScreenshotStorage.get_all"]
  key_links:
    - from: "veritas/screenshots/storage.py"
      to: "data/screenshots/{audit_id}"
      via: "file write operations"
      pattern: ".write_bytes"
    - from: "veritas/screenshots/storage.py"
      to: "pathlib.Path"
      via: "path operations and validation"
      pattern: "Path.*resolve"
---

<objective>
Create filesystem storage service for screenshots with directory organization, path validation, and clean deletion.

Purpose: Store binary screenshot files on filesystem instead of database, preventing database bloat and enabling efficient storage management. Screenshot references (paths) will be stored in database via AuditScreenshot model.

Output: veritas/screenshots/storage.py with ScreenshotStorage class handling all file operations.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistent-audit-storage/05-RESEARCH.md
@veritas/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Create ScreenshotStorage filesystem service</name>
  <files>
    - veritas/screenshots/storage.py
  </files>
  <action>
    Create veritas/screenshots/storage.py with ScreenshotStorage class:

    1. Import required modules:
       - base64, datetime, os, uuid
       - from pathlib import Path
       - from typing import Optional, Iterator

    2. Create veritas/screenshots/__init__.py (empty marker file)

    3. Implement ScreenshotStorage class:

       **__init__(self, base_dir: Path = Path("data/screenshots"))**:
       - Store base_dir as attribute
       - Create base_dir with parents=True, exist_ok=True

       **async save(self, audit_id: str, index: int, label: str, base64_data: Optional[str] = None, image_bytes: Optional[bytes] = None) -> tuple[str, int]**:
       - Validate audit_id (no path separators)
       - Create audit_dir = self.base_dir / audit_id, mkdir with exist_ok=True
       - Generate filename: {datetime.now().timestamp()}_{index}_{uuid4().hex[:8]}.png
       - filepath = audit_dir / filename
       - Validate filepath is within base_dir using _validate_path()
       - If base64_data: image_bytes = base64.b64decode(base64_data)
       - If no image_bytes: raise ValueError("Must provide either base64_data or image_bytes")
       - Write filepath.write_bytes(image_bytes)
       - Return (str(filepath), len(image_bytes))

       **_validate_path(self, path: Path) -> Path**:
       - Resolve path: resolved = path.resolve()
       - Resolve base: base_resolved = self.base_dir.resolve()
       - If not str(resolved).startswith(str(base_resolved)): raise ValueError("Path traversal attempt detected")
       - Return resolved

       **async delete(self, audit_id: str) -> None**:
       - Validate audit_id
       - audit_dir = self.base_dir / audit_id
       - If audit_dir.exists():
         * Iterate all files in audit_dir,.unlink()
         * audit_dir.rmdir()
       - Return silently if audit_id doesn't exist

       **async get_all(self, audit_id: str) -> list[dict]**:
       - Validate audit_id
       - audit_dir = self.base_dir / audit_id
       - If not exists: return []
       - Iterate all files in audit_dir, build return list with:
         {"filepath": str(f), "filename": f.name, "size_bytes": f.stat().st_size}
       - Sort by filename

       **async get_file(self, filepath: str) -> bytes**:
       - Convert filepath to Path
       - Validate using _validate_path()
       - Return filepath.read_bytes()

    Reference 05-RESEARCH.md lines 203-232 for ScreenshotStorage pattern.

    IMPORTANT: Do NOT modify routes or database code in this plan - this is a standalone storage service.
  </action>
  <verify>
    Run python -c "from veritas.screenshots.storage import ScreenshotStorage; s = ScreenshotStorage(); print('Storage base:', s.base_dir)"
  </verify>
  <done>
    ScreenshotStorage class exists with save, delete, get_all, get_file methods and path traversal protection.
  </done>
</task>

</tasks>

<verification>
1. Verify import: Run `python -c "from veritas.screenshots.storage import ScreenshotStorage; print('OK')"`
2. Verify path protection: Run python script that attempts ../ traversal - should raise ValueError
3. Verify directory creation: Run test that creates screenshot, verify directory exists in data/screenshots/
4. Verify deletion: Run test that creates screenshot, deletes, verify directory removed
</verification>

<success_criteria>
- veritas/screenshots/storage.py with ScreenshotStorage class
- save() creates directories and files, returns (filepath, size)
- delete() removes all files and directory for audit_id
- _validate_path() prevents path traversal attacks
- get_all() returns list of screenshot metadata
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistent-audit-storage/05-03-SUMMARY.md` with the storage service implementation notes.
</output>
