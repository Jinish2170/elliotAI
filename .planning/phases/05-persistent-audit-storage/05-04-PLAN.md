---
phase: 05-persistent-audit-storage
plan: 04
type: execute
wave: 3
depends_on: [05-01, 05-02, 05-03]
files_modified:
  - config/settings.py
  - backend/routes/audit.py
  - services/audit_runner.py
autonomous: true
requirements:
  - CORE-05
  - CORE-05-3
  - CORE-05-4
  - CORE-06-5

must_haves:
  truths:
    - Feature flag USE_DB_PERSISTENCE defaults to "true" to enable dual-write mode
    - When flag is true, audit routes write to both in-memory dict and SQLite database
    - /audit/{audit_id}/status reads from SQLite first, falls back to in-memory
    - audit result data is saved to database on completion (findings, screenshots, final scores)
    - ScreenshotStorage integration saves screenshot files and stores references in database
  artifacts:
    - path: "config/settings.py"
      provides: "USE_DB_PERSISTENCE feature flag"
      exports: ["USE_DB_PERSISTENCE", "should_use_db_persistence"]
    - path: "backend/routes/audit.py"
      provides: "Dual-write migration integration"
      contains: ["on_audit_started", "on_audit_completed", "on_audit_error implementations"]
    - path: "services/audit_runner.py"
      provides: "Audit runner modifications for screenshot persistence"
      exports: ["screenshot_storage"]
  key_links:
    - from: "backend/routes/audit.py"
      to: "veritas/db/repositories.py"
      via: "import AuditRepository"
      pattern: "from veritas.db.repositories import AuditRepository"
    - from: "backend/routes/audit.py"
      to: "veritas/screenshots/storage.py"
      via: "import ScreenshotStorage"
      pattern: "from veritas.screenshots.storage import ScreenshotStorage"
    - from: "backend/routes/audit.py"
      to: "config/settings.py"
      via: "import USE_DB_PERSISTENCE"
      pattern: "from config.settings import"
    - from: "services/audit_runner.py"
      to: "backend/routes/audit.py"
      via: "screenshot callback events"
      pattern: "send_event.*screenshot"
---

<objective>
Implement dual-write migration strategy with feature flag, integrating database writes alongside existing in-memory storage.

Purpose: Enable gradual migration from in-memory to persistent storage by writing to both backends simultaneously. The feature flag allows instant rollback if issues arise. Read operations are upgraded first, then writes follow.

Output: Functional dual-write mode with database persistence enabled by default.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistent-audit-storage/05-RESEARCH.md
@.planning/phases/05-persistent-audit-storage/05-01-SUMMARY.md
@.planning/phases/05-persistent-audit-storage/05-02-SUMMARY.md
@.planning/phases/05-persistent-audit-storage/05-03-SUMMARY.md
@backend/routes/audit.py
@config/settings.py
@services/audit_runner.py
</context>

<tasks>

<task type="auto">
  <name>Add USE_DB_PERSISTENCE feature flag to settings</name>
  <files>
    - config/settings.py
  </files>
  <action>
    Update config/settings.py to add database persistence flag:

    1. Add USE_DB_PERSISTENCE setting near other feature flags (after USE_SECURITY_AGENT):
       - USE_DB_PERSISTENCE: str = os.getenv("USE_DB_PERSISTENCE", "true").lower() == "true"

    2. Add helper function:
       - def should_use_db_persistence() -> bool:
           return USE_DB_PERSISTENCE

    Reference Phase 2 pattern for feature flag consistency (USE_SECURITY_AGENT pattern).
  </action>
  <verify>
    Run python -c "from config.settings import USE_DB_PERSISTENCE, should_use_db_persistence; print('USE_DB_PERSISTENCE:', USE_DB_PERSISTENCE, 'should_use:', should_use_db_persistence())"
  </verify>
  <done>
    USE_DB_PERSISTENCE setting exists and defaults to true; should_use_db_persistence() helper function exists.
  </done>
</task>

<task type="auto">
  <name>Implement database write handlers in audit routes</name>
  <files>
    - backend/routes/audit.py
  </files>
  <action>
    Update backend/routes/audit.py to implement the database write handlers (Plan 02 skeletons):

    1. Add imports:
       - from veritas.db.repositories import AuditRepository
       - from veritas.db.models import Audit, AuditFinding, AuditScreenshot, AuditStatus
       - from veritas.screenshots.storage import ScreenshotStorage
       - from config.settings import should_use_db_persistence

    2. Create instances at module level:
       - screenshot_storage = ScreenshotStorage()
       - _repo: AuditRepository | None = None  # Lazy initialize

    3. Implement on_audit_started(audit_id: str, data: dict, db: AsyncSession) -> None:
       - Check should_use_db_persistence()
       - If false, return
       - Create nonlocal _repo = AuditRepository(db) if None
       - Create Audit object with:
         * id=audit_id, url=data["url"], audit_tier=data["tier"], verdict_mode=data["verdict_mode"]
         * status=AuditStatus.QUEUED (or RUNNING if already started)
         * created_at=datetime.utcnow(), started_at=datetime.utcnow()
       - await _repo.create(audit)
       - Log: "Audit {audit_id} persisted to database"

    4. Implement on_audit_completed(audit_id: str, result: dict, db: AsyncSession) -> None:
       - Check should_use_db_persistence()
       - If false, return
       - Create nonlocal _repo = AuditRepository(db) if None
       - Fetch existing audit: audit = await _repo.get_by_id(audit_id)
       - If not found, return
       - Update audit fields from result:
         * trust_score = result.get("trust_score")
         * risk_level = result.get("risk_level")
         * narrative = result.get("narrative")
         * signal_scores = result.get("signal_scores", {})
         * site_type = result.get("site_type")
         * site_type_confidence = result.get("site_type_confidence")
         * security_results = result.get("security_results", {})
         * pages_scanned = result.get("pages_scanned", 0)
         * elapsed_seconds = result.get("elapsed_seconds", 0)
         * status = AuditStatus.COMPLETED
         * completed_at = datetime.utcnow()
       - Add findings from result.get("dark_pattern_summary", []):
         * For each finding: audit.findings.append(AuditFinding(...))
       - Wait, findings come through screenshot events - handle in screenshot event
       - await _repo.update(audit)
       - Log: "Audit {audit_id} result persisted to database"

    5. Implement on_audit_error(audit_id: str, error: str, db: AsyncSession) -> None:
       - Check should_use_db_persistence()
       - If false, return
       - Create nonlocal _repo = AuditRepository(db) if None
       - Fetch or create audit
       - Update status = AuditStatus.ERROR, error_message = error
       - await _repo.update(audit)
       - Log: "Audit {audit_id} error persisted to database"

    6. Update audit_status route to read from DB first:
       - Check should_use_db_persistence()
       - If true: audit = await _repo.get_by_id(audit_id), return database data if found
       - Fallback to _audits dict for compatibility

    7. Add screenshot event handler in stream_audit:
       - When sending events, detect if event has screenshot data
       - If event_type in ["screenshot_taken", "screenshot_analysis"]:
         * Extract base64_data, index, label from event
         * await screenshot_storage.save(audit_id, index, label, base64_data)
         * Create AuditScreenshot record linking to audit
       - Note: Check existing AuditRunner event structure for exact format

    IMPORTANT: The existing in-memory _audits dict stays unchanged - we add database writes as secondary persistence.
  </action>
  <verify>
    Run python -c "from backend.routes.audit import on_audit_started, on_audit_completed, on_audit_error; print('Handlers exist')"
  </verify>
  <done>
    All three event handlers implemented and call repository methods; status endpoint upgraded to read DB first.
  </done>
</task>

<task type="auto">
  <name>Update AuditRunner for screenshot persistence</name>
  <files>
    - services/audit_runner.py
  </files>
  <action>
    Update services/audit_runner.py to expose screenshot events for persistence:

    1. Check existing event structure - look for how Vision agent sends screenshot data
       - Find "screenshot" or "screenshot_taken" events in the event flow

    2. If screenshots are not already in events, modify vision_node or vision output to include:
       - { "type": "screenshot_taken", "screenshot_path": ..., "base64_data": ..., "index": N, "label": "..." }

    3. Ensure event data includes:
       - base64_data or file path converted to base64
       - index (sequential number)
       - label (agent-generated or "screenshot_{index}")

    Reference existing event patterns in services/audit_runner.py for consistency.

    If screenshots are already in events, just ensure the format matches what on_audit_completed expects.
  </action>
  <verify>
    Review AuditRunner source code to confirm screenshot events include base64_data, index, label fields
  </verify>
  <done>
    AuditRunner sends screenshot events with base64_data, index, label fields suitable for ScreenshotStorage.save()
  </done>
</task>

</tasks>

<verification>
1. Verify feature flag: Run `python -c "from config.settings import USE_DB_PERSISTENCE; print('Flag:', USE_DB_PERSISTENCE)"`
2. Verify dual-write: Start an audit, check both _audits dict and database contain the record
3. Verify screenshot storage: Run audit with vision agent, verify screenshots exist in data/screenshots/{audit_id}
4. Verify read from DB: Restart backend, query /audit/{audit_id}/status - should still return data (from DB)
5. Verify flag rollback: Set USE_DB_PERSISTENCE=false, run audit - should only write to memory
</verification>

<success_criteria>
- USE_DB_PERSISTENCE flag defaults to true and can be toggled
- Audit routes write to both in-memory and database when flag is true
- Screenshots saved to filesystem and references in AuditScreenshot table
- /audit/{audit_id}/status reads from database first
- Data persists across backend restart when USE_DB_PERSISTENCE=true
- Settting USE_DB_PERSISTENCE=false immediately reverts to in-memory only
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistent-audit-storage/05-04-SUMMARY.md` with dual-write implementation notes and rollback procedure.
</output>
