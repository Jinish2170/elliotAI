---
phase: 02-agent-architecture-refactor
plan: 02
type: execute
wave: 1
depends_on:
  - "02-01-PLAN.md"
files_modified:
  - veritas/agents/security_agent.py
  - veritas/analysis/__init__.py
  - veritas/analysis/security_headers.py
  - veritas/analysis/phishing_checker.py
  - veritas/analysis/redirect_analyzer.py
  - veritas/analysis/js_analyzer.py
  - veritas/analysis/form_validator.py
autonomous: true
requirements:
  - CORE-01-3
must_haves:
  truths:
    - "SecurityAgent discovers all 5 security modules from analysis/ directory automatically"
    - "SecurityAgent has dynamic methods: analyze_headers(), check_phishing(), analyze_redirects(), analyze_js(), validate_forms()"
    - "SecurityAgent.analyze(url) runs all discovered modules successfully"
    - "SecurityResult.modules_results contains results from all 5 modules"
    - "SecurityResult.composite_score is calculated from module scores (0-1 range)"
    - "SecurityResult.findings contains aggregated findings from all modules"
    - "Module discovery works by inspecting analysis/ directory (no hardcoded list)"
    - "All existing security module classes still work independently"
  artifacts:
    - path: "veritas/agents/security_agent.py"
      provides: "Module discovery and analyze() implementation"
      contains: ["_discover_modules", "_create_dynamic_methods", "analyze"]
      min_lines: 100
    - path: "veritas/analysis/__init__.py"
      provides: "SecurityModuleBase abstract class"
      contains: ["SecurityModuleBase", "discoverable"]
      min_lines: 20
  key_links:
    - from: "veritas/agents/security_agent.py"
      to: "veritas/analysis/*"
      via: "module discovery imports"
      pattern: "from analysis import|import.*analysis"
    - from: "veritas/analysis/security_headers.py"
      to: "veritas/analysis/__init__.py"
      via: "SecurityModuleBase inheritance"
      pattern: "SecurityModuleBase"
    - from: "veritas/agents/security_agent.py"
      to: "veritas/core/types.py"
      via: "SecurityResult aggregation"
      pattern: "SecurityResult|modules_results|composite_score"
    - from: "veritas/agents/security_agent.py"
      to: "veritas/analysis/*"
      via: "discoverable modules"
      pattern: "discover_modules|DiscoverSecurityModule"
---

# Phase 2 Plan 02: Module Auto-Discovery and SecurityResult Aggregation

**Wave:** 1 (Foundation)
**Depends on:** 02-01-PLAN.md (SecurityAgent data structures and class skeleton)
**Autonomous:** true

## Tasks

### Task: Create base analyzer class
Create `SecurityModuleBase` in `veritas/agents/security_agent.py` (or `veritas/analysis/__init__.py`):

1. Abstract base class with pattern-matching interface:
   - Module classes ending in "Analyzer" or "Checker" are discoverable
   - Class property/module_name(): str (e.g., "security_headers", "phishing_db")
   - Module property/category: str (e.g., "headers", "phishing")
   - async analyze*(url, page) -> result (to be implemented by subclasses)

2. Pattern for auto-discovery:
   - Module classes with `*analyze` method pattern
   - Module classes with `*_result` return type
   - Optional: can mark as `@discoverable` decorator for explicit opt-in

### Task: Implement module auto-discovery
Update `veritas/agents/security_agent.py`:

1. `_discover_modules()` implementation:
   - Import all modules from `analysis/` directory
   - Filter for classes that:
     - Inherit from SecurityModuleBase (or follow naming pattern)
     - End with "Analyzer" or "Checker"
     - Have an async analyze* method (e.g., analyze, check, validate)
   - Map module name -> class (e.g., "security_headers" -> SecurityHeaderAnalyzer)
   - Store in `self._discovered_modules`

2. Module method invocation pattern:
   - Based on naming convention:
     - analyze_headers() -> SecurityHeaderAnalyzer
     - check_phishing() -> PhishingChecker
     - analyze_redirects() -> RedirectAnalyzer
     - analyze_js() -> JSObfuscationDetector
     - validate_forms() -> FormActionValidator
   - Use reflection/`getattr` to call module methods dynamically
   - Store method references on SecurityAgent instance

3. Dynamic method creation at initialization:
   - On `__init__`, after discovering modules, create methods:
     ```python
     for module_name, module_class in self._discovered_modules.items():
         if module_name == "security_headers":
             self.analyze_headers = lambda url: self._run_module(module_class, url)
         elif module_name == "phishing_db":
             self.check_phishing = lambda url: self._run_module(module_class, url)
         # ... etc
     ```

### Task: Implement actual analyze() logic
Update `SecurityAgent.analyze()` to run discovered modules:

1. Module execution flow:
   - Initialize SecurityResult with url, timestamp
   - Get list of modules to run (from config or auto-discovered all)
   - For each module in priority order (headers, phishing, redirects, js, forms):
     - Track start time
     - Execute module via dynamic method
     - Capture result or error
     - Store result in modules_results[module_name]
     - Add module name to modules_run list
     - If module failed, add to modules_failed list
     - If fail_fast=True and module failed, break

2. SecurityResult aggregation:
   - Convert module results to per-module dicts
   - Extract findings from each module result:
     - SecurityHeaderAnalyzer: missing headers -> SecurityFinding items
     - PhishingChecker: flags, sources -> SecurityFinding items
     - RedirectAnalyzer: suspicion_flags -> SecurityFinding items
     - JSObfuscationDetector: flags -> SecurityFinding items
     - FormActionValidator: critical forms -> SecurityFinding items
   - Add all findings to result.findings list

3. Composite score calculation:
   - Score from SecurityHeaderAnalyzer.score
   - Score from PhishingChecker (1.0 if not phishing, 0.0 if phishing)
   - Score from RedirectAnalyzer.score
   - Score from JSObfuscationDetector.score (1.0 - risk_score)
   - Score from FormActionValidator.score
   - Weight each module score and compute composite:
     - Security headers: weight 0.2
     - Phishing: weight 0.3 (penalty heavy)
     - Redirects: weight 0.15
     - JS: weight 0.2
     - Forms: weight 0.15
   - Formula: composite = sum(module_score * weight) for each module

### Task: Update module classes (inherit from base)
Make existing analysis modules discoverable:

1. SecurityHeaderAnalyzer:
   - Add `module_name = "security_headers"`
   - Add `category = "headers"`
   - Already has `async analyze(url) -> SecurityHeadersResult`

2. PhishingChecker:
   - Add `module_name = "phishing_db"`
   - Add `category = "phishing"`
   - Already has `async check(url) -> PhishingResult`
   - Add wrapper method `async analyze(url)` that delegates to check

3. RedirectAnalyzer:
   - Add `module_name = "redirect_chain"`
   - Add `category = "redirects"`
   - Already has `async analyze(url) -> RedirectResult`

4. JSObfuscationDetector:
   - Add `module_name = "js_analysis"`
   - Add `category = "js"`
   - Has `async analyze(page, page_url) -> JSAnalysisResult`
   - Note: This module needs Playwright page - handle this difference

5. FormActionValidator:
   - Add `module_name = "form_validation"`
   - Add `category = "forms"`
   - Has `async validate(page, page_url) -> FormValidationResult`
   - Note: This module needs Playwright page - handle this difference

### Task: Handle modules requiring Playwright page
Some modules (JS analysis, forms) need Playwright page object:

1. Add optional `page` parameter to SecurityAgent.analyze:
   - `async def analyze(self, url: str, page: Optional[Page] = None) -> SecurityResult:`

2. Store `page` in instance state for use by modules that need it

3. For modules requiring page:
   - If page provided, pass it to module
   - If page not provided, skip these modules with logged warning
   - Add to result.modules_skipped list

## Verification Criteria

```python
# Auto-discovery finds all modules
agent = SecurityAgent()
assert len(agent._discovered_modules) == 5
assert "security_headers" in agent._discovered_modules
assert "phishing_db" in agent._discovered_modules
assert "redirect_chain" in agent._discovered_modules
assert "js_analysis" in agent._discovered_modules
assert "form_validation" in agent._discovered_modules

# Dynamic methods created
assert hasattr(agent, "analyze_headers")
assert hasattr(agent, "check_phishing")
assert hasattr(agent, "analyze_redirects")
assert hasattr(agent, "analyze_js")
assert hasattr(agent, "validate_forms")

# Analyze runs all modules
result = await agent.analyze("https://example.com")
assert len(result.modules_run) == 5
assert "security_headers" in result.modules_results
assert "phishing" in result.modules_results
assert "redirects" in result.modules_results
assert "js_analysis" in result.modules_results
assert "form_validation" in result.modules_results

# Findings aggregated
assert len(result.findings) >= 0
for finding in result.findings:
    assert hasattr(finding, "category")
    assert hasattr(finding, "severity")
    assert hasattr(finding, "evidence")

# Composite score calculated
assert 0.0 <= result.composite_score <= 1.0

# Time measured
assert result.analysis_time_ms > 0
```

## Notes
- Modules that need Playwright page (js_analysis, form_validation) may need special handling
- For basic implementation, these modules can skip if no page provided
- Full Playwright integration can be improved in future phases
- Module method naming convention maps: analyze/check/validate -> call appropriate method
