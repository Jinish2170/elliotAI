---
phase: 02-agent-architecture-refactor
plan: 03
type: execute
wave: 2
depends_on:
  - "02-01-PLAN.md"
  - "02-02-PLAN.md"
files_modified:
  - veritas/core/orchestrator.py
  - veritas/config/settings.py
  - veritas/core/ipc.py
  - veritas/agents/security_agent.py
autonomous: true
requirements:
  - CORE-01-4
must_haves:
  truths:
    - "security_node_with_agent() routes to SecurityAgent or security_node based on feature flags"
    - "Staged rollout works: URL hash consistently maps to same mode (agent/function)"
    - "SECURITY_AGENT_ROLLOUT=0.5 routes half URLs to agent, half to function"
    - "Auto-fallback triggers when SecurityAgent raises exception"
    - "Auto-fallback calls security_node and marks mode as 'function_fallback'"
    - "SecurityModeStarted and SecurityModeCompleted events emitted correctly"
    - "Mode tracking logged for each audit"
    - "security_node function unchanged and works independently"
    - "Rollback to function mode is instant (environment variable change only)"
  artifacts:
    - path: "veritas/core/orchestrator.py"
      provides: "Feature flag routing and auto-fallback"
      contains: ["security_node_with_agent", "USE_SECURITY_AGENT", "SECURITY_AGENT_ROLLOUT"]
      min_lines: 50
    - path: "veritas/config/settings.py"
      provides: "Rollout percentage helpers"
      contains: ["get_security_agent_rollout", "should_use_security_agent"]
      min_lines: 20
    - path: "veritas/core/ipc.py"
      provides: "Security mode progress events"
      contains: ["SecurityModeStarted", "SecurityModeCompleted"]
      min_lines: 15
  key_links:
    - from: "veritas/core/orchestrator.py"
      to: "veritas/agents/security_agent.py"
      via: "instantiate or call SecurityAgent"
      pattern: "from agents.security_agent import SecurityAgent"
    - from: "veritas/core/orchestrator.py"
      to: "veritas/config/settings.py"
      via: "feature flag checks"
      pattern: "should_use_security_agent|USE_SECURITY_AGENT"
    - from: "veritas/core/orchestrator.py"
      to: "veritas/core/ipc.py"
      via: "emit security mode events"
      pattern: "SecurityModeStarted|SecurityModeCompleted"
    - from: "veritas/core/orchestrator.py"
      to: "security_node function"
      via: "auto-fallback call"
      pattern: "security_node\(state\)"
---

# Phase 2 Plan 03: Feature Flag Infrastructure and Migration Path

**Wave:** 2 (Integration)
**Depends on:** 02-01-PLAN.md, 02-02-PLAN.md
**Autonomous:** true

## Tasks

### Task: Implement feature flag routing
Update `veritas/core/orchestrator.py`:

1. Add `security_node_with_agent()` wrapper function:
   - Checks USE_SECURITY_AGENT environment variable
   - Checks SECURITY_AGENT_ROLLOUT percentage (0.0 to 1.0)
   - Routes to SecurityAgent or security_node based on flags

2. Implement staged rollout logic:
   - Generate random hash from URL (consistent per URL)
   - Compare hash to SECURITY_AGENT_ROLLOUT threshold
   - Below threshold -> use SecurityAgent class
   - Above threshold -> use security_node function

3. Add auto-fallback mechanism:
   - Try SecurityAgent analyze() first
   - If SecurityAgent raises exception:
     - Log error with traceback
     - Log "Falling back to security_node function"
     - Call security_node function instead
     - Mark result with mode_used="function_fallback"

4. Add mode tracking:
   - Add "security_mode" field to state dict
   - Possible values: "agent", "function", "function_fallback"
   - Log which mode was used for each audit (for monitoring)

5. Update LangGraph security_node:
   - Replace existing security_node call with security_node_with_agent
   - Keep security_node function unchanged for rollback capability

### Task: Implement rollout percentage logic
Update `veritas/config/settings.py`:

1. Add rollout helpers:
   - `get_security_agent_rollout() -> float` - Read SECURITY_AGENT_ROLLOUT env var
   - `should_use_security_agent(url: str) -> bool` - Consistent hash-based decision

2. Implement consistent hash routing:
   - Use hashlib.md5(url.lower().encode()).hexdigest()
   - Convert first 8 hex chars to integer (0 to 2^32-1)
   - Normalize to 0.0-1.0 by dividing by 2^32
   - Return True if normalized value < SECURITY_AGENT_ROLLOUT

3. Log rollout configuration on startup:
   - Log "Security Agent: USE_SECURITY_AGENT={bool}, ROLLOUT={pct}%"
   - Log "Security Agent: Mode selection based on consistent URL hash"

### Task: Add ProgressEvent for mode tracking
Update `veritas/core/ipc.py`:

1. Add SecurityModeStarted event:
   ```python
   @dataclass
   class SecurityModeStarted(ProgressEvent):
       security_mode: str  # "agent" or "function" or "function_fallback"
       module_count: int = 0
       rollout_enabled: bool = False
   ```

2. Emit SecurityModeStarted before security analysis:
   - Orchestrator emits which mode was chosen
   - Includes module count and rollout status

3. Add SecurityModeCompleted event:
   ```python
   @dataclass
   class SecurityModeCompleted(ProgressEvent):
       security_mode: str
       analysis_time_ms: int
       modules_run: list[str]
       modules_failed: list[str]
       findings_count: int
       composite_score: float
   ```

4. Emit SecurityModeCompleted after security analysis:
   - Includes execution metrics for monitoring

### Task: Add SecurityAgent mode selection
Update `veritas/agents/security_agent.py`:

1. Add class method to check mode:
   ```python
   @classmethod
   def is_enabled(cls, url: str = "") -> bool:
       """Check if SecurityAgent should be used for this URL."""
       from config.settings import should_use_security_agent
       return should_use_security_agent(url)
   ```

2. Add environment variable getter:
   ```python
   @staticmethod
   def get_env_mode() -> str:
       """Return the configured mode: 'agent', 'function', or 'auto'."""
       import os
       mode = os.getenv("USE_SECURITY_AGENT", "true").lower()
       if mode == "false":
           return "function"
       if mode == "true":
           return "agent"
       return "auto"  # use rollout percentage
   ```

3. Add initialize() for pre-analysis setup:
   ```python
   async def initialize(self) -> None:
       """Initialize the agent (discover modules, set up resources)."""
       logger.info("Initializing SecurityAgent...")
       self._discover_modules()
       self._create_dynamic_methods()
       logger.info(f"SecurityAgent initialized with {len(self._discovered_modules)} modules")
   ```

### Task: Add CLI flags for testing
Update `veritas/config/settings.py` or CLI entry point:

1. Add environment variable checks:
   - USE_SECURITY_AGENT=true/false/auto (default: true for agent-first)
   - SECURITY_AGENT_ROLLOUT=0.0 to 1.0 (default: 1.0 for full rollout)

2. For testing:
   - Add --force-security-agent flag to bypass feature flag
   - Add --force-security-function flag to always use function mode

## Verification Criteria

```python
# Feature flag routes correctly
from agents.security_agent import SecurityAgent

# Agent mode
os.environ["USE_SECURITY_AGENT"] = "true"
assert SecurityAgent.get_env_mode() == "agent"

# Function mode
os.environ["USE_SECURITY_AGENT"] = "false"
assert SecurityAgent.get_env_mode() == "function"

# Auto mode (with rollout)
os.environ["USE_SECURITY_AGENT"] = "auto"
os.environ["SECURITY_AGENT_ROLLOUT"] = "1.0"
assert SecurityAgent.is_enabled("https://example.com") == True

# Rollout 50%
os.environ["SECURITY_AGENT_ROLLOUT"] = "0.5"
# Same URL always gets same decision
result1 = SecurityAgent.is_enabled("https://example.com")
result2 = SecurityAgent.is_enabled("https://example.com")
assert result1 == result2

# Auto-fallback works
state = {"url": "https://example.com"}
result = await security_node_with_agent(state)
assert "security_mode" in result["security_results"]
assert result["security_results"]["security_mode"] in ["agent", "function", "function_fallback"]
```

## Notes
- Consistent hash routing ensures same URL always gets same mode (important for debugging)
- Rollout percentage allows safe gradual rollout (10% -> 25% -> 50% -> 75% -> 100%)
- Auto-fallback ensures audits never fail due to agent architecture changes
- Mode tracking via ProgressEvent enables monitoring rollout success
- Environment variable controls allow instant rollback without code changes
- Default SecurityAgent first (USE_SECURITY_AGENT=true) - function mode requires opt-out
