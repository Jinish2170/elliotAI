---
id: 08-05
phase: 8
wave: 5
autonomous: false

objective: Integrate OSINT and CTI capabilities into Graph Investigator, enhancing it with multi-source entity profiles, cross-referencing, and intelligence network generation.

files_modified:
  - veritas/agents/graph_investigator.py
  - veritas/agents/__init__.py
  - veritas/config/settings.py

tasks: 7
requirements:
  - "OSINT-03"
  - "CTI-01"
  - "CTI-04"

depends_on: ["08-04"]
has_summary: true
gap_closure: false

must_haves:
  truths:
    - OSINTOrchestrator integrated into GraphInvestigator.__init
    - _run_osint_investigation() queries DNS, WHOIS, SSL, and threat intel sources
    - GraphResult extended with osint_sources, osint_consensus, cti_techniques
    - OSINT data added to knowledge graph as OSINTSourceNode, ConsensusNode, IOCNode
    - MITRE ATT&CK technique nodes added as MITRETacticNode
    - Enhanced graph score calculation includes OSINT (20%) and CTI (10%) factors
  artifacts:
    - veritas/agents/graph_investigator.py (modified with OSINT integration)
    - config.py (OSINT/CTI settings)
  key_links:
    - Depends on 08-04 for CThreatIntelligence integration
    - CTI-01 is PARTIALLY covered - entity profile building implemented, but cross-platform social engineering intelligence gathering is future enhancement

note:
  task_count_exceeded: This plan has 7 tasks, above the recommended 2-3 threshold. Consider splitting into 08-05a (integration setup) and 08-05b (graph enhancement) if execution priority allows.
---

# Plan 08-05: Graph Investigator OSINT Integration

**Goal:** Enhance Graph Investigator with integrated OSINT and CTI capabilities, providing multi-source entity profiles, cross-referencing, and intelligence network generation.

## Requirements

- OSINT-03: Enhance Graph Investigator with OSINT integration (multi-source entity profiles, cross-referencing, confidence scoring)
- CTI-01: Social engineering intelligence gathering pattern - PARTIAL (see below)
- CTI-04: Smart intelligence network with advanced reasoning (knowledge graph with OSINT nodes, enhanced scoring)

## Context

Phase 8 requires integrating the OSINT/CTI infrastructure into the existing GraphInvestigator agent. The GraphInvestigator already provides entity verification and knowledge graph construction; this enhancement adds OSINT intelligence and CTI analysis to that foundation.

**Current State:**
- GraphInvestigator has basic WHOIS, DNS, SSL (synchronous)
- Tavily search for entity verification
- Basic domain intel gathering
- No external threat intelligence feeds
- No multi-source consensus
- No CTI features

**Target State:**
- OSINTOrchestrator integrated for coordinated OSINT queries
- Entity profiles include OSINT data from 6+ sources
- Knowledge graph nodes include OSINT findings
- Graph score incorporates OSINT consensus and confidence
- CTI-lite analysis detects IOCs and maps to MITRE ATT&CK

**CTI-01 Gap Analysis:**
The original requirement CTI-01 explicitly asks for "Social engineering intelligence gathering pattern (follow trails across platforms, build entity profiles)". The current implementation provides:
- Entity profile correlation within the knowledge graph (Task 5: add OSINT nodes)
- Cross-referencing OSINT sources for entity data (Task 2: _run_osint_investigation)
- IOC detection and MITRE ATT&CK mapping (from CTI-03, covered in 08-04)

**However, this does NOT implement actual social engineering intelligence gathering:**
- No cross-platform entity tracking (e.g., checking company name across business registries, social networks, etc.)
- No following entity trails across external platforms
- Entity profiles are limited to OSINT source data for the same target, not discovered related entities

**Decision:** Mark CTI-01 as PARTIALLY covered. The enhanced entity profile building in GraphInvestigator is implemented, but true cross-platform social engineering intelligence gathering is a future enhancement.

## Tasks

<task>
<description>
Integrate OSINTOrchestrator into GraphInvestigator.__init__

Modify veritas/agents/graph_investigator.py:

1. Add imports near top of file:
   ```python
   from veritas.osint.orchestrator import OSINTOrchestrator
   from veritas.osint.reputation import ReputationManager, VerdictType
   from veritas.osint.cti import CThreatIntelligence
   from veritas.quality.consensus_engine import ConsensusEngine
   ```

2. In GraphInvestigator.__init__ method, after existing initialization:
   - Add `self._db_session = db_session` parameter to __init__ (if not present, add it)
   - Conditionally initialize OSINT/CTI components:
     ```python
     self._db_session = db_session
     if self._db_session:
         self._osint_orchestrator = OSINTOrchestrator(self._db_session)
         self._reputation_manager = ReputationManager()
         self._consensus_engine = ConsensusEngine(min_sources=2)
     else:
         self._osint_orchestrator = None
         self._reputation_manager = None
         self._consensus_engine = None

     self._cti = CThreatIntelligence()
     ```

3. Ensure all attributes are properly initialized and accessible to other methods

Maintain backward compatibility - OSINT operations should skip gracefully if no db session.
</description>
<files>
- veritas/agents/graph_investigator.py
</files>
<verification>
- Imports added at top: OSINTOrchestrator, ReputationManager, CThreatIntelligence, ConsensusEngine
- __init__ has _db_session parameter (added if not present)
- _osint_orchestrator initialized if _db_session is truthy
- _reputation_manager initialized if _db_session is truthy
- _consensus_engine initialized if _db_session is truthy (with min_sources=2)
- All attributes set to None when _db_session is falsy
- _cti initialized unconditionally (doesn't require db session)
- Existing __init__ still works (backward compatible)
</verification>
</task>

<task>
<description>
Add _run_osint_investigation method to GraphInvestigator

Add new method to GraphInvestigator class:

async def _run_osint_investigation(self, domain: str, hostname: str, ip_address: str) -> dict:
   """
   Run OSINT investigation using OSINTOrchestrator.

   Coordinated queries to DNS, WHOIS, SSL, threat intel sources.
   Returns dict with source results and consensus.
   """
   - Check if self._osint_orchestrator exists, return {} if None (log warning)
   - Initialize results dict
   - Query DNS if domain provided:
     * dns_result = await self._osint_orchestrator.query_with_retry("dns", "query", domain)
     * Add to results["dns"] if success
   - Query WHOIS if domain provided:
     * whois_result = await self._osint_orchestrator.query_with_retry("whois", "query", domain)
     * Add to results["whois"] if success
   - Query SSL if hostname provided:
     * ssl_result = await self._osint_orchestrator.query_with_retry("ssl", "query", hostname)
     * Add to results["ssl"] if success
   - Query threat intel sources if sources available:
     * threat_results = await self._osint_orchestrator.query_all(OSINTCategory.THREAT_INTEL, "domain", domain, max_parallel=2)
     * Update results dict with threat sources
   - Compute consensus using self._consensus_engine.compute_osint_consensus() if results exist
   - Return results dict

Results dict structure: {source_name: OSINTResult.__dict__, ..., "_consensus": consensus_dict}
</description>
<files>
- veritas/agents/graph_investigator.py
</files>
<verification>
- _run_osint_investigation() method exists with correct signature
- Returns {} if _osint_orchestrator is None (logs warning)
- Queries DNS when domain provided
- Queries WHOIS when domain provided
- Queries SSL when hostname provided
- Queries threat intel with query_all() for OSINTCategory.THREAT_INTEL
- max_parallel=2 for threat intel queries
- Calls consensus_engine.compute_osint_consensus() if results exist
- Stores consensus in results["_consensus"]
- Returns results dict
- Uses query_with_retry() for individual sources
- Source names match registered sources (dns, whois, ssl)
</verification>
</task>

<task>
<description>
Extend GraphResult dataclass with OSINT/CTI fields

Modify GraphResult dataclass in veritas/agents/graph_investigator.py:

Extend GraphResult with new OSINT/CTI fields:
```python
@dataclass
class GraphResult:
    # Existing fields...
    domain_intel: Optional[DomainIntel] = None
    claims_extracted: list[EntityClaim] = field(default_factory=list)
    verifications: list[VerificationResult] = field(default_factory=list)
    inconsistencies: list[GraphInconsistency] = field(default_factory=list)
    graph: Optional[nx.DiGraph] = None
    graph_score: float = 0.5
    meta_score: float = 0.5

    # MetaAnalyzer results
    meta_analysis: dict = field(default_factory=dict)
    ip_geolocation: dict = field(default_factory=dict)

    # Stats
    tavily_searches: int = 0
    errors: list[str] = field(default_factory=list)

    # New OSINT/CTI fields
    osint_sources: dict = field(default_factory=dict)
    osint_consensus: dict = field(default_factory=dict)
    osint_indicators: list = field(default_factory=list)
    cti_techniques: list = field(default_factory=list)
    threat_attribution: dict = field(default_factory=dict)
    threat_level: str = "none"
    osint_confidence: float = 0.0
```

Add new property methods:
```python
@property
def osint_score(self) -> float:
    """Calculate OSINT-based trust score (0-1, higher = more trustworthy)."""
    # Use consensus confidence if available
    if self.osint_consensus:
        status = self.osint_consensus.get("consensus_status", "")
        verdict = self.osint_consensus.get("verdict", "")

        if status == "confirmed":
            return 0.9 if verdict == "safe" else 0.3
        elif status == "conflicted":
            return 0.5  # Neutral on conflicts
        elif status == "likely":
            return 0.8 if verdict == "safe" else 0.4

    return 0.5  # Neutral if no OSINT data

@property
def has_threat_indicators(self) -> bool:
    """Check if there are threat indicators."""
    return self.threat_level in ["critical", "high", "medium"]
```

Maintain all existing fields and properties.
</description>
<files>
- veritas/agents/graph_investigator.py
</files>
<verification>
- GraphResult dataclass has all 7 new OSINT/CTI fields with correct types
- osint_sources: dict (default empty dict)
- osint_consensus: dict (default empty dict)
- osint_indicators: list (default empty list)
- cti_techniques: list (default empty list)
- threat_attribution: dict (default empty dict)
- threat_level: str (default "none")
- osint_confidence: float (default 0.0)
- osint_score property exists and returns correct values
- osint_score returns 0.9 for confirmed+safe, 0.3 for confirmed+malicious
- osint_score returns 0.5 for conflicted or no consensus
- osint_score returns 0.8 for likely+safe, 0.4 for likely+malicious
- osint_score returns 0.5 default with no OSINT data
- has_threat_indicators property exists
- has_threat_indicators returns True for critical/high/medium threat_level
- All existing fields and properties unchanged
- Existing domain_age_days and has_ssl properties still work
</verification>
</task>

<task>
<description>
Add OSINT nodes to knowledge graph

Add new method to GraphInvestigator class:

def _add_osint_nodes_to_graph(self, graph: nx.DiGraph, domain: str, osint_results: dict, result: GraphResult):
    """Add OSINT findings as nodes in the knowledge graph."""
   - Create Website node if not exists:
     * node_type="WebsiteNode"
     * domain=domain
     * osint_sources=list(osint_results.keys())

   - For each source in osint_results (skip "_consensus"):
     * Create OSINTSourceNode with: node_type, source, category, confidence, status
     * Add edge: Website -> OSINTSource (edge_type="VERIFIED_BY")

   - For consensus if available:
     * Create ConsensusNode with: node_type, status, verdict, agreement_count, has_conflict
     * Add edges: OSINTSource -> Consensus (edge_type="CONTRIBUTES_TO")

   - For each indicator in result.osint_indicators:
     * Create IOCNode with: node_type, ioc_type, value, threat_level
     * Add edge: Website -> IOC (edge_type="CONTAINS_IOC")

   - For each technique in result.cti_techniques:
     * Create MITRETacticNode with: node_type, technique_id, technique_name, tactic, confidence
     * Add edge: Website -> MITRE Technique (edge_type="EXHIBITS_PATTERN")

Node IDs should be unique:
- Website_{domain}
- OSINTSource_{source_name}
- OSINTConsensus_{domain}
- IOC_{ioc_type}_{value_first_20_chars}
- MITRE_{technique_id}
</description>
<files>
- veritas/agents/graph_investigator.py
</files>
<verification>
- _add_osint_nodes_to_graph() method exists with correct signature
- Creates Website_{domain} node with correct attributes
- Creates OSINTSource_{source} node for each source except "_consensus"
- Adds VERIFIED_BY edges from Website to OSINTSource nodes
- Creates OSINTConsensus_{domain} node if consensus exists
- Adds CONTRIBUTES_TO edges from OSINTSource to Consensus node
- Creates IOC nodes with unique IDs (ioc_type + value[:20])
- Adds CONTAINS_IOC edges from Website to IOC nodes
- Creates MITRE nodes with unique IDs (MITRE_{technique_id})
- Adds EXHIBITS_PATTERN edges from Website to MITRE nodes
- All nodes have node_type attribute
- Consensus node has has_conflict attribute
- IOC nodes have threat_level attribute
- MITRE nodes have technique_id, technique_name, tactic, confidence
</verification>
</task>

<task>
<description>
Enhance investigate() method with OSINT integration

Modify the existing investigate() method in GraphInvestigator:

1. Add page_html: Optional[str] = None parameter to investigate()

2. After existing domain investigation code, add OSINT investigation:
   ```python
   # Extract domain, hostname, IP address
   hostname = self._extract_hostname(url)
   ip_address = result.domain_intel.ip_address if result.domain_intel else ""

   # Run OSINT investigation
   osint_results = await self._run_osint_investigation(domain, hostname, ip_address)

   if osint_results:
       result.osint_sources = osint_results
       result.osint_consensus = osint_results.get("_consensus", {})

       # Enhance DomainIntel with OSINT data
       if result.domain_intel and "whois" in osint_results:
           whois_data = osint_results["whois"].get("data", {})
           result.domain_intel.age_days = whois_data.get("age_days", result.domain_intel.age_days)
           result.domain_intel.registrar = whois_data.get("registrar", result.domain_intel.registrar)
   ```

3. Add CTI-lite analysis if page_html and osint_results available:
   ```python
   # Run CTI-lite analysis if HTML available
   if page_html and osint_results:
       cti_result = await self._cti.analyze_threats(
           url, page_html, page_text, page_metadata, osint_results
       )

       result.osint_indicators = cti_result.get("indicators", [])
       result.cti_techniques = cti_result.get("mitre_techniques", [])
       result.threat_attribution = cti_result.get("attribution", {})
       result.threat_level = cti_result.get("threat_level", "none")
       result.osint_confidence = cti_result.get("confidence", 0.0)
   ```

4. After entity extraction, add OSINT nodes to graph:
   ```python
   # Add OSINT nodes to knowledge graph
   if osint_results:
       self._add_osint_nodes_to_graph(graph, domain, osint_results, result)
   ```

5. Recalculate graph score with OSINT (handled in next task)

Maintain all existing logic for backward compatibility.
</description>
<files>
- veritas/agents/graph_investigator.py
</files>
<verification>
- investigate() has page_html parameter with default None
- _run_osint_investigation() called with domain, hostname, ip_address
- result.osint_sources set if osint_results is not empty
- result.osint_consensus set from osint_results["_consensus"] if available
- DomainIntel.age_days updated from WHOIS data if present
- DomainIntel.registrar updated from WHOIS data if present
- CTI analysis runs if page_html and osint_results available
- result.osint_indicators set from cti_result["indicators"]
- result.cti_techniques set from cti_result["mitre_techniques"]
- result.threat_attribution set from cti_result["attribution"]
- result.threat_level set from cti_result["threat_level"]
- result.osint_confidence set from cti_result["confidence"]
- _add_osint_nodes_to_graph() called if osint_results exists
- All existing logic preserved
- No breaking changes to investigate() behavior
</verification>
</task>

<task>
<description>
Enhance graph score calculation with OSINT/CTI factors

Modify/create graph score calculation in GraphInvestigator:

Create new method:

def _calculate_enhanced_graph_score(self, result: GraphResult, graph: nx.DiGraph) -> float:
    """
    Calculate enhanced graph score incorporating OSINT and CTI signals.

    Weighting:
    - Existing graph signals (meta_score): 40%
    - Entity verification signals: 30%
    - OSINT consensus: 20%
    - CTI threat indicators: 10%
    """
   - meta_score = result.meta_score if result.meta_score else 0.5

   - Entity verification score:
     * Count verified entities vs total verifications
     * entity_score = verified / len(verifications) if verifications else 0.5

   - OSINT consensus score:
     * Map consensus_status to score: confirmed=0.9, likely=0.8, possible=0.6, insufficient=0.4, conflicted=0.5
     * If verdict=="malicious", invert score (1.0 - score)

   - CTI threat score:
     * Map threat_level to score: critical=0.0, high=0.2, medium=0.4, low=0.7, none=1.0
     * Blend with osint_confidence: cti_score = cti_score * (1 - confidence) + 0.5 * confidence

   - Weighted combination:
     * final_score = meta_score * 0.40 + entity_score * 0.30 + osint_score * 0.20 + cti_score * 0.10

   - Return max(0.0, min(1.0, final_score))

Update investigate() to use this method instead of existing graph_score calculation.
</description>
<files>
- veritas/agents/graph_investigator.py
</files>
<verification>
- _calculate_enhanced_graph_score() method exists with correct signature
- meta_score uses result.meta_score with 0.5 default
- entity_score calculated as verified / len(verifications) if verifications exist
- osint_score uses correct status_scores dict
- osint_score inverted (1.0 - score) when verdict=="malicious"
- cti_score threat_scores dict has correct values: critical=0.0, high=0.2, medium=0.4, low=0.7, none=1.0
- cti_score blended with osint_confidence correctly
- Final score uses weighted formula: 40% meta, 30% entity, 20% osint, 10% cti
- Final score clamped to 0.0-1.0 range
- investigate() calls _calculate_enhanced_graph_score()
- Works correctly when result fields are None/empty
</verification>
</task>

<task>
<description>
Add configuration settings for OSINT/CTI

Add OSINT/CTI configuration to config.py:

```python
# OSINT Configuration
GRAPH_ENABLE_OSINT = env.bool("GRAPH_ENABLE_OSINT", default=True)
GRAPH_OSINT_TIMEOUT_S = env.int("GRAPH_OSINT_TIMEOUT_S", default=30)
GRAPH_OSINT_MAX_PARALLEL = env.int("GRAPH_OSINT_MAX_PARALLEL", default=3)

# Threat Intel API Keys (optional)
URLVOID_API_KEY = env("URLVOID_API_KEY", default=None)
ABUSEIPDB_API_KEY = env("ABUSEIPDB_API_KEY", default=None)

# CTI Configuration
GRAPH_ENABLE_CTI = env.bool("GRAPH_ENABLE_CTI", default=True)
GRAPH_CTI_MIN_CONFIDENCE = env.float("GRAPH_CTI_MIN_CONFIDENCE", default=0.3)
```

These settings allow:
- Disabling OSINT/CTI features via environment variables
- Configuring timeouts and parallelism
- Setting API keys for threat intel sources
- Adjusting CTI confidence thresholds
</description>
<files>
- config.py
</files>
<verification>
- GRAPH_ENABLE_OSINT env.bool with default=True
- GRAPH_OSINT_TIMEOUT_S env.int with default=30
- GRAPH_OSINT_MAX_PARALLEL env.int with default=3
- URLVOID_API_KEY env with default=None
- ABUSEIPDB_API_KEY env with default=None
- GRAPH_ENABLE_CTI env.bool with default=True
- GRAPH_CTI_MIN_CONFIDENCE env.float with default=0.3
- All settings use correct variable naming (uppercase)
- All settings have appropriate default values
- Existing config settings unchanged
</verification>
</task>

## Must Haves (Goal-Backward Verification)

### Success Criteria for OSINT-03 / CTI-01 / CTI-04

- [ ] OSINTOrchestrator integrated into GraphInvestigator.__init
- [ ] _run_osint_investigation() queries DNS, WHOIS, SSL, and threat intel sources
- [ ] GraphResult extended with osint_sources, osint_consensus, cti_techniques
- [ ] OSINT data added to knowledge graph as OSINTSourceNode, ConsensusNode, IOCNode
- [ ] MITRE ATT&CK technique nodes added as MITRETacticNode
- [ ] Enhanced graph score calculation includes OSINT (20%) and CTI (10%) factors
- [ ] investigate() method runs OSINT and CTI analysis
- [ ] Configuration settings added for OSINT/CTI features
- [ ] Tests pass for OSINT integration and CTI-lite analysis

### CTI-01 Partial Coverage Notes

**Implemented:**
- Entity profile building within GraphInvestigator (osint_sources data)
- Cross-referencing OSINT sources for entity data (_run_osint_investigation aggregates multiple sources)
- Knowledge graph entity correlation (OSINT, IOC, and MITRE nodes linked to Website node)

**Not Implemented (Future Enhancement):**
- Cross-platform entity tracking (checking entity across business registries, social networks, etc.)
- Following entity trails across external platforms
- Discovery of related entities beyond the immediate target
- Social engineering intelligence gathering beyond pattern-based detection

**Gap Justification:**
Per RESEARCH.md, social media verification APIs are limited or require paid access. Many major platforms (Twitter/X, Facebook, Instagram) have restricted API access. True cross-platform entity tracking would require integration with multiple proprietary APIs that are not freely available.

## Dependencies

- 08-04: CTI Features (provides CThreatIntelligence, AttackPatternMapper, IOCDetector)

## Requirements Coverage

- OSINT-03: Enhance Graph Investigator with OSINT integration (multi-source entity profiles, cross-referencing, confidence scoring) - COMPLETE
- CTI-01: Social engineering intelligence gathering pattern - PARTIAL (entity profile building implemented; cross-platform tracking is future enhancement)
- CTI-04: Smart intelligence network with advanced reasoning (knowledge graph with OSINT nodes, enhanced scoring) - COMPLETE

## Notes

- Backward compatible: maintains existing GraphInvestigator interface
- OSINT operations skip gracefully if no db session provided
- Consensus-based scoring prevents false positives from single sources
- Conflict detection preserves contradictory findings for manual review
