---
phase: 11-agent-theater-showcase
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/config/agent_personalities.ts
  - frontend/src/hooks/useEventSequencer.ts
  - frontend/src/lib/types.ts
  - frontend/src/lib/store.ts
  - frontend/src/components/audit/AgentCard.tsx
  - frontend/src/components/audit/NarrativeFeed.tsx
autonomous: true
requirements:
  - SHOWCASE-01
  - SHOWCASE-04
user_setup: []

must_haves:
  truths:
    - All 5 agents have distinct personalities with emoji, name, and catchphrases
    - WebSocket events arrive with sequence numbers for ordering
    - Event sequencer reorders out-of-order events before processing
    - Agent "flexing" messages appear when tasks complete (e.g., "Vision found 3 dark patterns!")
    - Personality messages use dynamic parameters (e.g., "{count} findings detected")
  artifacts:
    - path: frontend/src/config/agent_personalities.ts
      provides: AgentPersona interface, AGENT_PERSONALITIES constant with 5 agent personalities
      exports: ["AgentPersona", "AGENT_PERSONALITIES", "getPersonalityMessage"]
      min_lines: 120
    - path: frontend/src/hooks/useEventSequencer.ts
      provides: Event buffering and reordering hook
      exports: ["useEventSequencer", "EventSequencer"]
      min_lines: 80
    - path: frontend/src/lib/types.ts
      provides: Extended Finding type with bbox, AgentPersona interface
      exports: ["Finding", "SequencedEvent"]
      min_lines: 170
    - path: frontend/src/lib/store.ts
      provides: Updated useAuditStore with sequencer integration
      exports: ["useAuditStore"]
      min_lines: 320
  key_links:
    - from: frontend/src/components/audit/NarrativeFeed.tsx
      to: frontend/src/config/agent_personalities.ts
      via: import AGENT_PERSONALITIES
      pattern: "from '@/config/agent_personalities' import .*"
    - from: frontend/src/lib/store.ts
      to: frontend/src/hooks/useEventSequencer.ts
      via: useEventSequencer integration in handleEvent
      pattern: "useEventSequencer"
    - from: frontend/src/components/audit/AgentCard.tsx
      to: frontend/src/config/agent_personalities.ts
      via: agent personality display
      pattern: "AGENT_PERSONALITIES\\.\\[phase\\]"
---

<objective>
Create agent personality system for character-based communication and event sequencer for reliable WebSocket message ordering, enabling engaging agent interactions with proper event handling.

Purpose: Establish the foundation for Agent Theater by defining distinct agent personalities (SCOUT: stealthy observer, VISION: analytical pattern detector, SECURITY: protective auditor, GRAPH: investigative connector, JUDGE: authoritative adjudicator) and ensuring WebSocket events are properly ordered despite network latency.

Output: AgentPersona configuration with 5 personalities, useEventSequencer hook for buffering/reordering, extended types with bbox and sequencing support, updated useAuditStore with sequencer integration, agent personality messages in NarrativeFeed and AgentCard.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-agent-theater-showcase/11-RESEARCH.md
@frontend/src/lib/types.ts
@frontend/src/lib/store.ts
@frontend/src/components/audit/AgentCard.tsx
@frontend/src/components/audit/NarrativeFeed.tsx

# Key interfaces from existing codebase

From frontend/src/lib/types.ts:
```typescript
export type Phase = "init" | "scout" | "security" | "vision" | "graph" | "judge";
export interface Finding {
  id: string;
  category: string;
  pattern_type: string;
  severity: "low" | "medium" | "high" | "critical";
  confidence: number;
  description: string;
  plain_english: string;
  screenshot_index?: number;
}
export interface LogEntry {
  timestamp: string;
  agent: string;
  message: string;
  level: "info" | "warn" | "error";
}
export const PHASE_META: Record<Phase, { label: string; icon: string; description: string }>;
```

From frontend/src/lib/store.ts:
```typescript
interface AuditStore {
  handleEvent: (event: Record<string, unknown>) => void;
  // Current handleEvent processes these event types:
  // - phase_start, phase_complete, phase_error
  // - finding, screenshot, stats_update, log_entry
  // - site_type, security_result
  // - audit_result, audit_complete, audit_error
}
```

# Existing component patterns

From frontend/src/components/audit/AgentCard.tsx:
- Uses PHASE_META for agent icons and descriptions
- Shows status (waiting/active/complete/error) with visual indicators
- Shows progress bar for active agents
- Shows summary message when complete

From frontend/src/components/audit/NarrativeFeed.tsx:
- Shows phase transition cards with agent icons
- Shows finding alert cards with severity
- Shows "Did You Know?" cards between phases
- Uses AnimatePresence for smooth animations
- Auto-scrolls to latest entry
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent personality configuration system</name>
  <files>frontend/src/config/agent_personalities.ts</files>
  <action>
    Create frontend/src/config/agent_personalities.ts with:

    1. AgentPersona interface with fields:
       - emoji: string (visual icon)
       - name: string (character name)
       - personality: string (trait description)
       - catchphrases: {
           working: string[] (messages while agent is active),
           complete: string[] (messages on task completion),
           success: string[] (messages on success),
           error: string[] (messages on error)
         }
       - color: string (Tailwind color for accent)

    2. AGENT_PERSONALITIES constant with 5 entries:
       - scout: {emoji: "üïµÔ∏è", name: "Stealth Scout", personality: "Cautious observer, discovers the terrain", ...catchphrases}
       - vision: {emoji: "üëÅÔ∏è", name: "Vision Agent", personality: "Detail-oriented pattern detector", ...catchphrases}
       - security: {emoji: "üõ°Ô∏è", name: "Security Sentinel", personality: "Protective auditor, checks all locks", ...catchphrases}
       - graph: {emoji: "üåê", name: "Network Investigator", personality: "Investigative connector, reveals hidden ties", ...catchphrases}
       - judge: {emoji: "‚öñÔ∏è", name: "Forensic Judge", personality: "Authoritative adjudicator, weighs all evidence", ...catchphrases}

    3. Catchphrase patterns with variables:
       - working: ["Scouting the perimeter...", "Analyzing visual patterns...", "Checking security headers...", "Cross-referencing entities...", "Weighing all evidence..."]
       - complete: ["Map complete! Found {count} pages.", "Visual scan complete! {count} findings detected.", "Security audit complete! {count} checks passed.", "Network analysis complete! {count} entities verified.", "Verdict complete! Trust score: {score}."]
       - success: ["Landed safely!", "Pattern identified!", "All systems clear!", "Connection established!", "Justice served!"]
       - error: ["Navigation blocked...", "Visual obscured...", "Security breach detected...", "Network unreachable...", "Evidence insufficient..."]

    4. getPersonalityMessage function:
       - getPersonalityMessage(agent: Phase, context: "working" | "complete" | "success" | "error", params?: Record<string, unknown>): string
       - Selects random message from catchphrases array
       - Replaces variables like {count}, {score} with provided params
       - Falls back to generic message if agent not found

    Use existing PHASE_META icons as fallback/refernce, but add more character depth.
  </action>
  <verify>
    <automated>cd frontend && npx tsx -e "import { AGENT_PERSONALITIES, getPersonalityMessage } from './src/config/agent_personalities.ts'; console.log(Object.keys(AGENT_PERSONALITIES)); console.log(getPersonalityMessage('vision', 'complete', {count: 5}))"</automated>
  </verify>
  <done>frontend/src/config/agent_personalities.ts created with 5 agent personalities, catchphrases with variable substitution, and getPersonalityMessage helper function</done>
</task>

<task type="auto">
  <name>Task 2: Create event sequencer hook for WebSocket event ordering</name>
  <files>frontend/src/hooks/useEventSequencer.ts</files>
  <action>
    Create frontend/src/hooks/useEventSequencer.ts with:

    1. SequencedEvent interface extending existing event types:
       - sequence: number (monotonically increasing from backend)
       - type: string (event type)
       - data: Record<string, unknown> (event payload)

    2. EventSequencer class with methods:
       - addEvent(event: SequencedEvent): void - buffers event
       - getReadyEvents(): SequencedEvent[] - returns events in order starting from nextSequence
       - getNextSequence(): number - returns expected next sequence number
       - reset(): void - clears buffer and resets sequence counter

    3. Internal buffering logic:
       - store: Map<number, SequencedEvent> for out-of-order buffering
       - nextSequence: number (starts at 0)
       - addEvent() stores event in map, then calls flushReady()
       - flushReady() collects all consecutive events starting from nextSequence

    4. useEventSequencer hook:
       - Returns { eventSequencer, addEvent, getReadyEvents }
       - Maintains EventSequencer instance across re-renders (useRef)
       - Call addEvent() on each WebSocket message arrival
       - Call getReadyEvents() to retrieve ordered events for processing

    NOTE: This hook will be used in useAuditStore's handleEvent method to ensure events are processed in correct order.
  </action>
  <verify>
    <automated>cd frontend && npx tsx -e "import { useEventSequencer } from './src/hooks/useEventSequencer'; const sequencer = new useEventSequencer(); sequencer.addEvent({sequence: 3, type: 'test', data: {}}); sequencer.addEvent({sequence: 1, type: 'test', data: {}}); sequencer.addEvent({sequence: 2, type: 'test', data: {}}); console.log(sequencer.getReadyEvents().map(e => e.sequence).join(','))"</automated>
  </verify>
  <done>frontend/src/hooks/useEventSequencer.ts created with EventSequencer class buffering events and useEventSequencer hook for React integration</done>
</task>

<task type="auto">
  <name>Task 3: Integrate sequencer into store and add personality messages to components</name>
  <files>frontend/src/lib/types.ts, frontend/src/lib/store.ts, frontend/src/components/audit/AgentCard.tsx, frontend/src/components/audit/NarrativeFeed.tsx</files>
  <action>
    Modify frontend/src/lib/types.ts:
    1. Add bbox to Finding interface: bbox?: [number, number, number, number] (x, y, width, height percentages)
    2. Add sequence field to LogEntry: sequence?: number

    Modify frontend/src/lib/store.ts:
    1. Import useEventSequencer hook
    2. Add sequencer instance to AuditStore state (using useRef pattern)
    3. Modify handleEvent() to:
       - Extract sequence number from event if present
       - Pass to eventSequencer.addEvent()
       - Call eventSequencer.getReadyEvents() and process in order
       - Fallback to immediate processing if no sequence number (backward compatibility)
    4. Add new event handler for "agent_personality":
       - Extract agent, context, params from event
       - Update phases[agent].message with personality message
       - Add personality log entry to logs array

    Modify frontend/src/components/audit/AgentCard.tsx:
    1. Import getPersonalityMessage from agent_personalities
    2. Add personality_message display when phase is active:
       - Show random working message from agent personality
       - Update message every 8-10 seconds (useEffect with setInterval)
    3. Add "flex" message display when phase completes:
       - Use personality.complete message with count/summary params
       - Show in larger, emphasized text

    Modify frontend/src/components/audit/NarrativeFeed.tsx:
    1. Import getPersonalityMessage from agent_personalities
    2. Add PersonalityCard component for agent personality events:
       - Display agent emoji, name, and personality message
       - Color code by agent phase
    3. Modify PhaseCard to use agent personality name instead of PHASE_META label
    4. Add personality events to feed when agent_personality events are received

    NOTE: Backend modifications needed in future plan to add sequence numbers to all WebSocket events.
  </action>
  <verify>
    <automated>cd frontend && npm run build 2>&1 | head -20</automated>
  </verify>
  <done>Event sequencer integrated into useAuditStore, Finding type extended with bbox field, AgentCard displays personality messages, NarrativeFeed shows personality cards</done>
</task>

</tasks>

<verification>
Event sequencer correctly reorders out-of-order events, personality messages display correctly for all 5 agents, flex messages appear on task completion, backward compatibility maintained for events without sequence numbers
</verification>

<success_criteria>
- AGENT_PERSONALITIES exported with 5 distinct agent personalities
- getPersonalityMessage({agent, context, params}) returns formatted message with variable substitution
- EventSequencer.addEvent() buffers events and getReadyEvents() returns ordered sequence
- useAuditStore.handleEvent() uses sequencer for events with sequence field
- AgentCard shows personality working messages and completion flex messages
- NarrativeFeed shows PersonalityCard events for agent activity
- Finding type has bbox field (x, y, width, height percentages)
- TypeScript compiles without errors
- Plan committed with atomic task commits
</success_criteria>

<output>
After completion, create `.planning/phases/11-agent-theater-showcase/11-01-SUMMARY.md`
</output>
