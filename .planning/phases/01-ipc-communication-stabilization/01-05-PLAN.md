---
phase: 01-ipc-communication-stabilization
plan: 05
type: execute
wave: 4
depends_on:
  - 01-04
files_modified:
  - veritas/tests/test_ipc_integration.py
  - backend/tests/test_audit_runner_queue.py
autonomous: true
requirements:
  - CORE-06

must_haves:
  truths:
    - Integration test passes for full Queue IPC audit
    - Auto-fallback to stdout works when Queue fails
    - Validation test compares Queue vs stdout results
    - Windows spawn context test passes
    - All tests follow existing test patterns
  artifacts:
    - path: veritas/tests/test_ipc_integration.py
      provides: Integration tests for Queue IPC in subprocess context
      min_lines: 80
    - path: backend/tests/test_audit_runner_queue.py
      provides: Tests for AuditRunner Queue integration and fallback
      min_lines: 60
  key_links:
    - from: veritas/tests/test_ipc_integration.py
      to: veritas/core/orchestrator.py
      via: from veritas.core.orchestrator import VeritasOrchestrator
      pattern: from veritas\.core\.orchestrator import
    - from: backend/tests/test_audit_runner_queue.py
      to: backend/services/audit_runner.py
      via: from backend.services.audit_runner import AuditRunner
      pattern: from backend\.services\.audit_runner import

---

<objective>
Add comprehensive integration tests for Queue IPC, auto-fallback behavior, and Windows spawn context compatibility.

Purpose: Verify Queue IPC works end-to-end, fallback mechanism functions correctly, and results match stdout mode for validation.

Output: Integration test files covering Queue IPC, fallback, result comparison, and Windows compatibility.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-ipc-communication-stabilization/01-CONTEXT.md
@.planning/phases/01-ipc-communication-stabilization/01-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md

# Codebase references
@C:/files/coding dev era/elliot/elliotAI/veritas/tests/test_veritas.py (test patterns)
@C:/files/coding dev era/elliot/elliotAI/veritas/core/ipc.py (created in Plan 01)
@C:/files/coding dev era/elliot/elliotAI/veritas/core/orchestrator.py (modified in Plan 03)
@C:/files/coding dev era/elliot/elliotAI/backend/services/audit_runner.py (modified in Plan 04)

# Prior plans
@.planning/phases/01-ipc-communication-stabilization/01-01-SUMMARY.md (not yet created)
@.planning/phases/01-ipc-communication-stabilization/01-02-SUMMARY.md (not yet created)
@.planning/phases/01-ipc-communication-stabilization/01-03-SUMMARY.md (not yet created)
@.planning/phases/01-ipc-communication-stabilization/01-04-SUMMARY.md (not yet created)
</context>

<tasks>

<task type="auto">
  <name>Create integration tests for Queue IPC in subprocess context</name>
  <files>veritas/tests/test_ipc_integration.py</files>
  <action>
    Create new file `veritas/tests/test_ipc_integration.py` with tests:

    1. Import required modules: pytest, asyncio, multiprocessing, unittest.mock

    2. `test_orchestrator_with_queue_mode()` test:
       - Create Queue with maxsize=100
       - Create VeritasOrchestrator(progress_queue=queue)
       - Run minimal audit (mock NIM client, skip actual network calls)
       - Verify events are received from Queue
       - Verify no ##PROGRESS: markers in Queue events
       - Verify ProgressEvent structure (type, phase, step, pct, detail)

    3. `test_orchestrator_stdout_fallback()` test:
       - Create VeritasOrchestrator(progress_queue=None)
       - Run minimal audit
       - Verify stdout mode uses ##PROGRESS: markers
       - Capture stdout output and parse markers

    4. `test_queue_full_handling()` test:
       - Create Queue with maxsize=1
       - Create VeritasOrchestrator with small Queue
       - Run audit that produces >1 event
       - Verify safe_put handles backpressure
       - Verify audit completes despite Queue being full

    5. `test_progress_event_structure()` test:
       - Import ProgressEvent
       - Create minimal ProgressEvent
       - Verify all required fields exist
       - Verify timestamp defaults correctly

    6. `test_mode_determination_priorities()` test:
       - Import determine_ipc_mode function
       - Test CLI flag priority (returns queue when use_queue_ipc=True)
       - Test ENV variable priority (uses QUEUE_IPC_MODE)
       - Test default rollout (respects QUEUE_IPC_ROLLOUT)

    Use mocks for NIM client to avoid external dependencies. Follow existing test patterns from `test_veritas.py`.
  </action>
  <verify>
    cd veritas && python -m pytest tests/test_ipc_integration.py -v -x
  </verify>
  <done>
    All integration tests pass, confirming Queue IPC works in subprocess context, stdout fallback works, and mode determination follows priority hierarchy.
  </done>
</task>

<task type="auto">
  <name>Create tests for AuditRunner Queue integration and fallback</name>
  <files>backend/tests/test_audit_runner_queue.py</files>
  <action>
    Create new file `backend/tests/test_audit_runner_queue.py` with tests:

    1. Create directory if it doesn't exist: `backend/tests/`
    2. Create `backend/tests/__init__.py` (empty file)

    3. File content:
       ```python
       """Tests for AuditRunner Queue IPC integration."""

       import asyncio
       import os
       import sys
       from pathlib import Path
       from unittest.mock import AsyncMock, MagicMock, patch

       import pytest

       # Add backend and veritas to path
       sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))
       sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent / "veritas"))

       from backend.services.audit_runner import AuditRunner
       from core.ipc import IPC_MODE_QUEUE, create_queue

       # Tests here
       ```

    4. `test_ipc_mode_determination()` test:
       - Create AuditRunner instance
       - Set QUEUE_IPC_MODE environment to "queue"
       - Verify ipc_mode returns "queue"
       - Set QUEUE_IPC_MODE to "stdout"
       - Verify ipc_mode returns "stdout"

    5. `test_queue_creation_in_runner()` test:
       - Mock environment to force Queue mode
       - Create AuditRunner
       - Verify progress_queue is not None
       - Verify queue has correct maxsize (1000)

    6. `test_reader_send_events()` test:
       - Create Queue directly
       - Put test events into Queue
       - Create mock send callback
       - Run _read_queue_and_stream for one iteration
       - Verify mock_send was called with correct event structure

    7. `test_fallback_on_queue_creation_failure()` test:
       - Mock Manager.Queue to raise Exception
       - Create AuditRunner
       - Verify ipc_mode falls back to "stdout"
       - Verify progress_queue is None

    8. `test_windows_spawn_context_set()` test:
       - Verify multiprocessing has spawn method set
       - This validates backend/__init__.py configured correctly

    Use mocks for subprocess to avoid actual process spawning. Follow pytest conventions.
  </action>
  <verify>
    cd backend && python -m pytest tests/test_audit_runner_queue.py -v -x
  </verify>
  <done>
    All AuditRunner Queue tests pass, confirming mode determination, Queue creation, event reading, and fallback behavior work correctly.
  </done>
</task>

</tasks>

<verification>
1. Integration tests verify Queue IPC works end-to-end
2. Fallback tests confirm stdout mode works when Queue fails
3. Mode determination tests validate priority hierarchy
4. Windows spawn context test confirms multiprocessing configured
5. All tests follow existing test patterns and conventions
6. Tests cover edge cases (full Queue, missing env vars, etc.)
</verification>

<success_criteria>
1. Integration test file created with subprocess Queue IPC tests
2. AuditRunner test file created with Queue integration tests
3. All tests use mocks appropriately (no external dependencies)
4. Tests verify fallback behavior and error handling
5. Windows spawn context validated in tests
6. Test file structure follows existing project conventions
</success_criteria>

<output>
After completion, create `.planning/phases/01-ipc-communication-stabilization/01-05-SUMMARY.md`
</output>
