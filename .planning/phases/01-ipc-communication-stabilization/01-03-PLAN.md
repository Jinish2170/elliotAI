---
phase: 01-ipc-communication-stabilization
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
  - 01-02
files_modified:
  - veritas/core/orchestrator.py
  - veritas/core/ipc.py
autonomous: true
requirements:
  - CORE-02-3
  - CORE-02-4

must_haves:
  truths:
    - VeritasOrchestrator accepts optional progress_queue parameter
    - _emit() method emits via Queue when available, falls back to stdout
    - All progress events in audit() use _emit() method
    - No ##PROGRESS: markers when Queue is active
    - Queue.put() uses timeout and handles queue.Full gracefully
  artifacts:
    - path: veritas/core/orchestrator.py
      contains: VeritasOrchestrator class with progress_queue parameter
      contains: _emit() method with dual-mode support
    - path: veritas/core/ipc.py
      provides: safe_put helper for Queue with timeout handling
      exports: safe_put
  key_links:
    - from: veritas/core/orchestrator.py
      to: veritas/core/ipc.py
      via: from veritas.core.ipc import ProgressEvent, safe_put
      pattern: from veritas\.core\.ipc import ProgressEvent
    - from: veritas/core/orchestrator.py
      to: progress_queue
      via: queue.put()
      pattern: self\.progress_queue\.put\(.*timeout=.*\)|safe_put\(self\.progress_queue,

---

<objective>
Modify VeritasOrchestrator to support dual-mode emission via Queue or stdout based on progress_queue parameter availability.

Purpose: Enable orchestrator to emit structured ProgressEvent objects to Queue when available, with automatic fallback to stdout parsing for backward compatibility.

Output: Modified `veritas/core/orchestrator.py` with dual-mode _emit(), and safe_put helper in `veritas/core/ipc.py`.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-ipc-communication-stabilization/01-CONTEXT.md
@.planning/phases/01-ipc-communication-stabilization/01-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md

# Codebase references
@C:/files/coding dev era/elliot/elliotAI/veritas/core/orchestrator.py
@C:/files/coding dev era/elliot/elliotAI/veritas/core/ipc.py (created in Plan 01)

# Prior plans
@.planning/phases/01-ipc-communication-stabilization/01-01-SUMMARY.md (not yet created)
@.planning/phases/01-ipc-communication-stabilization/01-02-SUMMARY.md (not yet created)
</context>

<tasks>

<task type="auto">
  <name>Add safe_put helper to ipc.py for Queue timeout handling</name>
  <files>veritas/core/ipc.py</files>
  <action>
    Extend `veritas/core/ipc.py` with safe_put helper:

    1. Add `safe_put(queue: multiprocessing.Queue, event: Any, logger, timeout: float = 1.0) -> bool` function that:
       - Tries `queue.put(event, timeout=timeout)` inside try block
       - Returns True on success
       - Catches queue.Empty and queue.Full exceptions
       - Logs WARNING on queue.Full: "Progress queue full, dropping event: {event_type}"
       - On Full: Optionally tries to remove oldest (queue.get(timeout=0.1)) and retry once
       - Returns False on failure
       - Catches any other Exception, logs ERROR, returns False

    2. Import `queue` module at top if not already imported

    3. Use event.get("type") or event.type if ProgressEvent dataclass for logging

    4. Add docstring explaining backpressure handling per RESEARCH.md anti-patterns

    This prevents Queue exhaustion from blocking the audit subprocess.
  </action>
  <verify>
    python -c "
from veritas.core.ipc import create_queue, safe_put
import logging
logging.basicConfig(level=logging.WARNING)
q = create_queue(maxsize=2)
assert safe_put(q, {'type': 'test'}, logging.getLogger('test')) == True
assert safe_put(q, {'type': 'test2'}, logging.getLogger('test')) == True
assert safe_put(q, {'type': 'test3'}, logging.getLogger('test')) == False  # Should fail, queue full
print('OK')
"
  </verify>
  <done>
    safe_put successfully handles Queue.put with timeout, logs on backpressure, returns success/failure status.
  </done>
</task>

<task type="auto">
  <name>Modify VeritasOrchestrator to accept progress_queue and implement dual-mode emission</name>
  <files>veritas/core/orchestrator.py</files>
  <action>
    Modify `veritas/core/orchestrator.py` with dual-mode emission:

    1. Add import at top:
    ```python
    from core.ipc import ProgressEvent, safe_put
    ```

    2. Modify `VeritasOrchestrator.__init__` to accept progress_queue:
       ```python
       def __init__(self, progress_queue: Optional[multiprocessing.Queue] = None):
           self._graph = build_audit_graph()
           self._compiled = self._graph.compile()
           self.progress_queue = progress_queue
       ```

    3. Replace the nested `_emit` function in `audit()` method with a class method:
       ```python
       def _emit(self, phase: str, step: str, pct: int, detail: str = "", **extra):
           """Emit progress via Queue or fallback to stdout."""
           if self.progress_queue is not None:
               event = ProgressEvent(
                   type="progress",
                   phase=phase,
                   step=step,
                   pct=pct,
                   detail=detail,
                   summary=extra.get("summary") or {},
                   timestamp=self.state.get("elapsed_seconds", time.time()) if hasattr(self, "state") else None,
               )
               # Add extra fields to event
               for k, v in extra.items():
                   if k not in ("summary",):
                       setattr(event, k, v)
               safe_put(self.progress_queue, event, logger, timeout=1.0)
           else:
               # Legacy stdout fallback (existing behavior)
               msg = {"phase": phase, "step": step, "pct": pct, "detail": detail}
               msg.update(extra)
               print(f"##PROGRESS:{_json.dumps(msg)}", flush=True)
       ```

    4. Change all `_emit(...)` calls to `self._emit(...)` throughout the audit() method (approximately 15-20 calls at lines: 987, 993, 996, 1001, 1006, 1018, 1021, 1025, 1032, 1039, 1044, 1052, 1058, 1065, 1069, 1095)

    5. Keep existing stdout marker format unchanged for backward compatibility when progress_queue is None

    DO NOT modify node functions (scout_node, vision_node, etc.) - only the audit() method and _emit.
  </action>
  <verify>
    python -c "
from veritas.core.orchestrator import VeritasOrchestrator
# Test with no queue (stdout mode)
orch = VeritasOrchestrator(progress_queue=None)
assert orch.progress_queue is None
print('OK - stdout mode works')

# Test with queue
from veritas.core.ipc import create_queue
q = create_queue(maxsize=100)
orch2 = VeritasOrchestrator(progress_queue=q)
assert orch2.progress_queue is q
print('OK - queue mode works')
"
  </verify>
  <done>
    VeritasOrchestrator accepts progress_queue parameter, emits via Queue when available, falls back to stdout when None, all _emit() calls updated.
  </done>
</task>

</tasks>

<verification>
1. VeritasOrchestrator.__init__ accepts progress_queue parameter
2. _emit() method checks progress_queue existence
3. Queue mode uses ProgressEvent dataclass and safe_put with timeout
4. Stdout mode maintains existing ##PROGRESS: marker format
5. All _emit() calls in audit() method updated to use self._emit()
6. No regression in existing stdout behavior
</verification>

<success_criteria>
1. VeritasOrchestrator accepts optional progress_queue parameter
2. Emission via Queue when progress_queue is set
3. Automatic fallback to stdout when progress_queue is None
4. safe_put handles Queue backpressure with timeout and logging
5. All existing code paths continue working (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/01-ipc-communication-stabilization/01-03-SUMMARY.md`
</output>
