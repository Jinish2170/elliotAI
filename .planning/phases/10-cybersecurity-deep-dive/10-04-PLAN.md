---
phase: 10-cybersecurity-deep-dive
plan: 04
type: execute
wave: 4
depends_on: ["10-01", "10-02", "10-03"]
files_modified:
  - veritas/agents/security_agent.py
  - veritas/core/types.py
  - veritas/core/orchestrator.py
autonomous: true
requirements:
  - SEC-01
  - SEC-02
user_setup: []

must_haves:
  truths:
    - SecurityAgent rewritten to use tier-based execution (FAST → MEDIUM → DEEP)
    - FAST tier modules execute in parallel under 5 seconds via asyncio.gather
    - MEDIUM tier modules execute in parallel under 15 seconds
    - DEEP tier modules execute sequentially under 30 seconds
    - CVSS scores calculated for findings using Phase 9 CVSSCalculator
    - Darknet threat intel from Phase 8 correlated with security findings
    - SecurityResult extended with execution_time_ms, modules_executed, darknet_correlation
  artifacts:
    - path: veritas/agents/security_agent.py
      provides: Rewritten SecurityAgent with tier execution, CVSS integration, darknet correlation
      exports: ["SecurityAgent", "SecurityResult"]
      min_lines: 200
    - path: veritas/core/types.py
      provides: Extended SecurityFinding, SecurityResult types
      exports: ["SecurityFinding", "SecurityResult"]
    - path: veritas/core/orchestrator.py
      provides: Orchestrator integration with new SecurityAgent
      modifications: ["Update security node to use new SecurityAgent.analyze()"]
  key_links:
    - from: veritas/agents/security_agent.py
      to: veritas/analysis/security/utils.py
      via: import get_all_security_modules, group_modules_by_tier
      pattern: "from analysis.security.utils import get_all_security_modules, group_modules_by_tier"
    - from: veritas/agents/security_agent.py
      to: veritas/cwe/cvss_calculator.py
      via: import CVSSCalculator
      pattern: "from veritas.cwe.cvss_calculator import CVSSCalculator"
    - from: veritas/agents/security_agent.py
      to: veritas/agents/graph_investigator.py
      via: import DarknetThreatIntel or OSINTOrchestrator
      pattern: "from agents.graph_investigator import.*"
    - from: veritas/core/orchestrator.py
      to: veritas/agents/security_agent.py
      via: import SecurityAgent
      pattern: "from agents.security_agent import SecurityAgent"
---

<objective>
Rewrite SecurityAgent to use tier-based parallel execution of 25+ security modules, integrate CVSS scoring from Phase 9, correlate darknet threat intelligence from Phase 8, and update orchestrator to use the new agent.

Purpose: Replace function-based security analysis with extensible module architecture enabling efficient tier-grouped parallel execution of 25+ security modules (FAST/MEDIUM/DEEP), CVSS severity scoring via Phase 9 integration, and darknet threat correlation via Phase 8 OSINT/CTI components.

Output: Rewritten SecurityAgent with tier-based execution (FAST parallel <5s → MEDIUM parallel <15s → DEEP sequential <30s), CVSS score calculation, darknet correlation, extended SecurityResult with execution metrics, orchestrator integration.
</objective>

<execution_context>
@C:/Users/hp/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@planning/phases/10-cybersecurity-deep-dive/10-RESEARCH.md
@planning/phases/09-judge-orchestrator/09-02-SUMMARY.md
@planning/phases/08-osint-cti-integration/08-05-SUMMARY.md
@veritas/agents/security_agent.py
@veritas/core/orchestrator.py
@veritas/cwe/cvss_calculator.py

# Existing core types

From veritas/core/types.py (check if SecurityFinding/SecurityResult exist):
```python
# Existing SecurityFinding may need extension to add cwe_id and cvss_score
# Existing SecurityResult may need extension to add execution_time_ms, modules_executed, darknet_correlation
```

# Phase 8 OSINT/CTI integration

From Phase 8 Summary (08-05):
- OSINTOrchestrator with DNS, WHOIS, SSL sources
- ConsensusEngine with multi-source consensus
- GraphInvestigator._run_osint_investigation() for threat intel
- DarknetThreatIntel.analyze_exposure(url) for darknet exposure
- OSINT result fields: osint_sources, osint_consensus, osint_indicators, cti_techniques, threat_attribution

# Phase 9 CVSS/CVSE integration

From Phase 9 Summary (09-01):
- CVSSCalculator.calculate_base_score_from_finding(finding) for scoring
- CWEMapper.map_finding_to_cwe(category_id, pattern_type) for CWE ID mapping
- CVSS v4.0 metrics with Attack Vector, Complexity, CIA impact

# Orchestrator integration pattern

From veritas/core/orchestrator.py (Phase 9 pattern):
- Agent execution: result = await self.vision_agent.analyze(...)
- Circuit breaker integration: result = await self.fallback_manager.execute_with_fallback(...)
- Timeout application: with asyncio.timeout(agent_timeout)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend core types (SecurityFinding, SecurityResult) for CVSS and darknet correlation</name>
  <files>veritas/core/types.py</files>
  <action>
    Check existing SecurityFinding and SecurityResult in core/types.py and extend if needed:

    1. SecurityFinding extension:
       - If SecurityFinding exists with (category_id, pattern_type, severity, confidence, description, evidence):
         * Add cwe_id: Optional[str] field
         * Add cvss_score: Optional[float] field
         * Add recommendation: str field
         * Add url_finding: bool field
       - If SecurityFinding does not exist, create it with all fields from base.py

    2. SecurityResult extension:
       - If SecurityResult exists with (findings, composite_score, severity):
         * Add execution_time_ms: int field (default 0)
         * Add modules_executed: int field (default 0)
         * Add modules_failed: int field (default 0)
         * Add darknet_correlation: Optional[dict] field (store darknet threat intel)
       - Ensure findings is List[SecurityFinding]

    3. Import SecurityFinding and SecurityResult from core.types for use in security modules:
       - If they exist in core/types, update veritas/analysis/security/base.py to import from core.types
       - Maintain backward compatibility with existing code

    Important: Do NOT break existing code that uses SecurityFinding/SecurityResult.
    Use Optional fields for backward compatibility.
  </action>
  <verify>
    <automated>python -c "from core.types import SecurityFinding, SecurityResult; print('SecurityFinding fields:', [f for f in dir(SecurityFinding) if not f.startswith('_')]); print('SecurityResult fields:', [f for f in dir(SecurityResult) if not f.startswith('_')])"</automated>
  </verify>
  <done>SecurityFinding extended with cwe_id, cvss_score fields, SecurityResult extended with execution_time_ms, modules_executed, modules_failed, darknet_correlation fields</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite SecurityAgent with tier-based execution and CVSS integration</name>
  <files>veritas/agents/security_agent.py</files>
  <action>
    Rewrite SecurityAgent to use tier-based execution:

    1. New SecurityAgent class properties:
       - _modules_by_tier: Dict[SecurityTier, List[type[SecurityModule]]] (cache)
       - use_tier_execution: bool = False (feature flag for gradual rollout)
       - enable_cvss: bool = True (CVSS scoring enable)
       - enable_darknet: bool = True (darknet correlation enable)

    2. Private method _load_modules():
       - Calls get_all_security_modules() from analysis.security.utils
       - Groups by tier using group_modules_by_tier()
       - Caches in _modules_by_tier class variable

    3. Public async method analyze():
       - Signature: async def analyze(self, url: str, page_content: Optional[str] = None, headers: Optional[dict] = None, dom_meta: Optional[dict] = None, use_tier_execution: bool = False) -> SecurityResult
       - If use_tier_execution=True:
         * Call _load_modules()
         * Execute FAST tier in parallel (asyncio.gather with timeouts)
         * Execute MEDIUM tier in parallel
         * Execute DEEP tier sequentially
         * Collect all findings
         * Apply _calculate_cvss_scores() if enable_cvss=True
         * Return SecurityResult with execution_time_ms, modules_executed, findings
       - If use_tier_execution=False:
         * Maintain backward compatibility with existing function-based execution

    4. Private method _calculate_cvss_scores(findings: List[SecurityFinding]) -> List[SecurityFinding]:
       - Import CVSSCalculator from veritas.cwe.cvss_calculator
       - For each finding:
         * If finding.cwe_id is None, find it via cwemapper.map_finding_to_cwe()
         * If finding.cvss_score is None, calculate it via cvss_calculator.calculate_base_score_from_finding()
       - Return updated findings

    5. Execution pattern for tier execution:
       - FAST tier: asyncio.gather(*fast_tasks, return_exceptions=True)
       - MEDIUM tier: asyncio.gather(*medium_tasks, return_exceptions=True)
       - DEEP tier: sequential for loop with try/except for each module
       - Track execution time via time.time()
       - Track modules_executed and modules_failed counts

    6. Maintain backward compatibility:
       - Keep existing function-based imports (SecurityHeaderAnalyzer, PhishingChecker, etc.)
       - Keep _MODULE_PRIORITY, _MODULE_WEIGHTS for old execution path
       - Use use_tier_execution flag to switch between old and new execution

    7. Add module discovery and tier execution tests in analyze():
       - Auto-discover modules via get_all_security_modules()
       - Confirm tier grouping: {FAST: [3], MEDIUM: [12], DEEP: [10]} (25 total)

    Maintain existing docstring and agent documentation in updated file.
  </action>
  <verify>
    <automated>python -c "from agents.security_agent import SecurityAgent; import asyncio; async def test(): agent = SecurityAgent(); print('SecurityAgent created'); print(f'use_tier_execution: {agent.use_tier_execution}'); print(f'enable_cvss: {agent.enable_cvss}'); print(f'enable_darknet: {agent.enable_darknet}'); asyncio.run(test())"</automated>
  </verify>
  <done>SecurityAgent rewritten with tier-based execution (FAST parallel → MEDIUM parallel → DEEP sequential), CVSS scoring integration, backward compatibility flag use_tier_execution</done>
</task>

<task type="auto">
  <name>Task 3: Add darknet threat correlation and update orchestrator integration</name>
  <files>veritas/agents/security_agent.py, veritas/core/orchestrator.py</files>
  <action>
    Add darknet threat correlation to SecurityAgent and update orchestrator:

    1. In SecurityAgent, add private method _correlate_darknet_threats(url: str, findings: List[SecurityFinding]) -> List[SecurityFinding]:
       - Import DarknetThreatIntel from veritas.agents.graph_investigator (or OSINTOrchestrator)
       - Call darknet_intel.analyze_exposure(url) with offline_feeds=True
       - If darknet exposure detected (has_exposure=True, threat_level="high"):
         * For specific finding types: owasp_a03 (injection), owasp_a07 (auth), owasp_a10 (ssrf)
         * Elevate severity: medium → high, high → critical
         * Boost finding.confidence by 1.5x (max 1.0)
         * Append evidence: " | [DARKNET CORRELATION: Elevated due to threat feed exposure]"
         * Add metadata: "darknet_correlation": true to finding
       - Return updated findings
       - Save darknet intel dict to darknet_correlation field in SecurityResult

    2. Update SecurityAgent.analyze() to call _correlate_darknet_threats if enable_darknet=True:
       - After CVSS calculation, call: findings = await self._correlate_darknet_threats(url, findings)
       - Store darknet intel dict: result.darknet_correlation = darknet_intel_data

    3. Update veritas/core/orchestrator.py:
       - Find the security_node() or security agent execution code
       - Update to use new SecurityAgent.analyze() with use_tier_execution=True
       - Ensure Scout's dom_meta is passed to SecurityAgent.analyze()
       - Ensure headers from HTTP response are passed to SecurityAgent.analyze()
       - Update SecurityResult handling to use new fields (execution_time_ms, modules_executed)
       - Add timeout integration via asyncio.timeout (already in orchestrator)

    4. Add feature flag for tier execution:
       - In orchestrator, add SECURITY_USE_TIER_EXECUTION = os.getenv("SECURITY_USE_TIER_EXECUTION", "false").lower() == "true"
       - Pass use_tier_execution from orchestrator to SecurityAgent.analyze()
       - Default to false for backward compatibility

    5. Maintain orchestrator integration:
       - Ensure ProgressEmitter receives security module progress (emits per-tier completion)
       - Ensure DegradedResult handling for circuit breaker integration
       - Ensure existing tests still pass with tier_execution=False

    6. Add error handling:
       - If get_all_security_modules() fails, log and fall back to function-based execution
       - If darknet correlation fails, log and continue without correlation
       - If CVSS calculation fails, log and continue without CVSS scores

    Add docstring to _correlate_darknet_threats explaining the correlation logic and threat elevation criteria.
  </action>
  <verify>
    <automated>python -c "from agents.security_agent import SecurityAgent; from core.orchestrator import Orchestrator; print('SecurityAgent and Orchestrator import successfully'); print('SecurityAgent has _correlate_darknet_threats:', hasattr(SecurityAgent, '_correlate_darknet_threats'))"</automated>
  </verify>
  <done>Darknet threat correlation integrated in SecurityAgent, orchestrator updated to use tier execution, feature flag SECURITY_USE_TIER_EXECUTION for gradual rollout</done>
</task>

</tasks>

<verification>
SecurityAgent with tier execution auto-discovers 25+ modules, modules grouped by tier (FAST=3, MEDIUM=12, DEEP=10), CVSS scores calculated for all findings, darknet threat intel correlated with specific vulnerability types, orchestrator uses new SecurityAgent.analyze() when SECUR
ITY_USE_TIER_EXECUTION=true
</verification>

<success_criteria>
- SecurityFinding extended with cwe_id, cvss_score, recommendation, url_finding fields
- SecurityResult extended with execution_time_ms, modules_executed, modules_failed, darknet_correlation fields
- SecurityAgent rewritten with use_tier_execution, enable_cvss, enable_darknet feature flags
- SecurityAgent._load_modules() auto-discovers modules via get_all_security_modules()
- SecurityAgent.analyze() executes FAST (parallel <5s) → MEDIUM (parallel <15s) → DEEP (sequential <30s)
- SecurityAgent._calculate_cvss_scores() uses CVSSCalculator from Phase 9
- SecurityAgent._correlate_darknet_threats() uses DarknetThreatIntel from Phase 8
- Darknet correlation elevates severity (medium→high, high→critical) for owasp_a03, owasp_a07, owasp_a10 findings
- Orchestrator updated to call SecurityAgent.analyze(use_tier_execution=True)
- SECURITY_USE_TIER_EXECUTION environment variable controls rollout
- Backward compatibility maintained (function-based execution still works)
- All existing tests pass with false flags
- Plan committed with atomic task commits
</success_criteria>

<output>
After completion, create `.planning/phases/10-cybersecurity-deep-dive/10-04-SUMMARY.md`
</output>
